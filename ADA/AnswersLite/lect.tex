\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage[english, russian] {babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{minted}
\usepackage{float}
\usepackage{amssymb}

\title{Структуры данных и анализы. База}
\author{silvia.lesnaia }


\begin{document}

\maketitle


\section{Определение алгоритма. Свойства алгоритмов
(пять основных свойств: дискретность,
детерминированность, понятность, массовость,
результативность). Причины возникновения
формального определения алгоритма. Основные
типы алгоритмических моделей (перечислить).}


\subsection{Алгоритм} 

конечный набор правил, который определяет последовптельность
операций для решения конкретного множества задач и обладает пятью важными
чертами: конченость, определенность, ввод вывод, эффективность (Д. Кнут)


\subsection{Основные свойства алгоритмов}

Дискретность — алгоритм должен решать задачу, проделывая конечное множество
элементарных шагов, каждый из которых выполняется во времени дискретно.

Детерминирванность (определённость): в кажжддый момент времени шаг работы
алгоритма однозначно определяется состоянием системы.

Понятность : алгоритм должен включать команды, понятные исполнителю.

Завершаемость (результативность, конечность) : при корректно заданных исходных
данных алгоритм должен давать результат за конечное число шагов.


Массовость (универсальность): задача может не иметь универсального решения.

\subsection{Причины возникновения формального определения алгоритма}

Доказательство алгоритмической неразрешимости требовало формального уточнения
понятия алгоритма. В отличие от создания конкретных алгоритмов, доказательство
невозможности должно содержать высказывание обо всех мыслимых алгоритмах. Без
формального определения невозможно было говорить о всех возможных алгоритмах и,
следовательно, доказать, что задача алгоритмически неразрешима.



\subsection{Основные типы алгоритмических моделей}

 Алгоритм как некое детерминированное устройство - абстрактные машины. Машина
Тьюринга и машина Поста.

 Алгоритм как процедура вычисления некой числовой функции. Рекурсивные функции
Черча.

 Алгоритм как последовательность преобразований цепочек в каком-либо алфавите.
(Комбинаторные операции над словами). Нормальные алгоритмы Маркова.


\section{Машина Поста. Описание, примеры. Тезис Поста}

\subsection{Машина Поста}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 172730.png}
\end{figure}


\subsection{Описание, примеры}

Инструкции программы занумерованы и выполняются последовательно, оператор
условного перехода ? осуществляет перемещение к конкретному номеру.
Программа может завершить работу тремя путями:

 Останов по команде ! называется результативным и указывает на корректность
алгоритма

 Останов при выполнении недопустимой команды (запись метки, где она есть, или
стирание, где её нет)

 Зацикливание

Пример: переместим головку к первой пустой позиции справа
1. -> 2
2. ? 3; 


\subsection{Тезис Поста}

Всякий алгоритм представим в форме машины Поста
— Эмиль Леон Пост
Потому что алгоритм по Посту — это программа для машины Поста (c) Пост


\section{Машина Тьюринга. Описание, способы задания
(список команд, таблица переходов, граф
переходов). Конфигурации МТ. Вычислимость по
Тьюрингу. }

\subsection{Машина Тьюринга}


\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 173113.png}
\end{figure}


\subsection{Описание, способы задания
(список команд, таблица переходов, граф
переходов)}

\begin{figure} [H]
  \centering
    \includegraphics
    [width=1\linewidth]{Снимок экрана 2025-11-20 173118.png}
\end{figure}

Граф переходов

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 175607.png}
\end{figure}

\subsection{Конфигурации машины Тьюринга}

Конфигурация совокупность внутреннего состояния, состояния ленты, положения
головки на ленте.

Визуально её можно представить следующим образом:

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 173236.png}
\end{figure}

\subsection{Вычислимость по
Тьюрингу}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 173304.png}
\end{figure}

\section{Введение в теорию рекурсивных функций.
Простейшие функции. Оператор суперпозиции.
Оператор примитивной рекурсии. Оператор
минимизации. Примитивно-рекурсивные и
частично-рекурсивные функции. Тезис Черча.
Примеры и способы задания рекурсивных
функций.}


\subsection{Простейшие функции}

Числовые фукнции, значение которых можно установить посредством некоторого
алгоритма, называются вычислимыми функциями.

Пример:

s(x) = x + 1 - функци непосредственного следования, также опрелённая для всех целых
нотрицательных начений своего аргуумента;


Z($x_1,x_2,... x_n$) = 0  нуль-функция, которая определена для всех неотрицательных
значений аргумента;


\subsection{Оператор суперпозиции}


Оператором суперпозиции S называется подстановка в функцию от n переменных m
функций от n одних и тех же переменных. Она дает новую от n переменных.


В операции суперпозиции $S^{m+1}$ индекс сверху указывает на число функций.

Таким образом, при помози оператора суперпозиции и функции выбора можно выразить
любую подстановку функции в функцию.

Свойства операции суперпозиции: 

1.Операция суперпозиции сохраняет свойство всюду определенности функций

2.Операция суперпозиции сохраняет свойство алгоритмической вычислимости функций.

Примеры суперпозиции функции


f(x) = 0 и g(x) = x + 1 получим фунцию h(x) = g(f(x)) = 0 + 1 = 1


\subsection{Оператор примитивной рекурсии}


Оператор примитивной рекурси задается следующим образом:
Рекурсия ведется по одному аргументу, все остальные считаются параметрами

Функция полученная с помощью операции примитивной рекурсии

f = R(g,h)

R - оператор примитивной рекурсии.


\subsection{Основные свойства операции примитивной рекурсии.}

Всякая ПРФ является всюду определённой функцией. Всякая ПРФ является алгоритмически
вычислимой.


Определение. Функция примитивно-рекурсивная если она является элементарной или может
быть получена из элементарных функций с помозью конечного числа применений
операторов тождества, суперпозиции и примитивной рекурсии.

 Если некоторые функции являются примитивно-рекурсивными, то в результате
применения к ним операторов суперпозиции или примитивной рекурсии можно
получить новые ПРФ

 Существует три возможности доказательства того, что функция является примитивнорекурсивной:

 1. Показать, что заданная функция является простейшей.

2. Показать, что заданная функция построена с помощью оператора суперпозиции.

3. Показать, что заданная функция построена с помощью оператора примитивной рекурсии.

\subsection{Оператор минимизации}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 174930.png}
\end{figure}


\subsection{Тезис Чёрча}


Определение. Частично-рекурсивная функция — функция, которая может быть
получина из простейших функции с помощью конечного числа операторов суперпозиции,
примитивной рекурсии и минимизации.
Определение. Общерекурсивная функция — всюду определённая частично-рекурсивная
функция

Тезис Чёрча (для частично рекурсивных функций) Класс алгоритмически вычислимых
функций совпадает с классом всех частично рекурсивных функций. Принятие данного
тезиса позволяет истолковывать доказательство, что некоторая функция не является
частичо рекурсивной, как доказательство отсутствия алгоритма вычисления ее
значений

Всякая функция, вычислимая с помощью машины Тьюринга, является частично рекусивной.
Всякая частично рекурсивная функция вычислима на машине Тьюринга


\subsection{Примеры и способы задания рекурсивных
функций}

Рекурсивная функция может быть задана:

 Прямо, когда даётся базовый и рекурсивный случай

 Косвенно, когда две функции вызывают друг друга

\section{Нормальные алгоритмы Маркова.}

Класс нормально вычислимых функций совпадает с классами частично рекурсивных
функций и вычислимых по Тьюрингу


Определение. Марковская подстановка — операция над словами, задаваемая парой слов
(P, Q), которая заменяет в слове R первое вхождение P на Q, обозначается P -> Q.
Пустое слово обозначается как $\wedge $.

Определение. Схема нормального алгоритма Маркова — это упорядоченный конечный
список подстановок в алфавите A

Нормальный алгоритм перерабатывает слово V в слово W.

Принцип нормализации Маркова — функция, заданная в некотором алфавите,
нормально вычислима $\rightarrow \exists $ алгоритм нахождения её значений


\section{Алгоритмически неразрешимые задачи. Примеры
алгоритмически неразрешимых задач. Методы
доказательства алгоритмической
неразрешимости. Проблема останова МТ и
самоприменимости (доказательство
неразрешимости). }

\subsection{Алгоритмически неразрешимые задачи}

Для алгоритмически невычислимых функций не существует алгоритма решения. Это
означает невозможность решения всех задач одного класса одним и тем же приёмом, при
этом конкретные задачи могут быть решаемыми.

\subsection{Примеры алгоритмически неразрешимых задач}

Пример. h(n) возвращает 0 или 1 - найдутся ли в числе $\pi$ n идущих подряд девяток.
Функция алгоритмически неразрешима, так как число $\pi$ иррационально и по природе числа
неизвестно, существует ли решение для всех n

\subsection{ Методы доказательства алгоритмической неразрешимости}


Прямой метод использует диагональный метод Кантора. Заключается он в следующем: из
предполоожения о разрешимости данной проблемы в ходе рассуждений приходят к
противоречию.


 Косвенный метод состоит в следующем: показывается, что разрешимость исследуемой
проблемы влечёт разрешимость проблемы, о которой уже известно, что она неразрешима.
Метод сведения часто бывает более удобным, чем прямой метод. Применяя метод
сведения, обычно ссылаются на искусственные задачи, которые не представляют
самостоятельного интереса, но для которых легко непосредственно доказать их
неразрешимость

\subsection{Проблема останова МТ в самоприменимости (доказательство
неразрешимости)}

Определение. Самоприменимость — частный случай проблемы остановки. Означает
свойство алгоритма успешно завершаться на данных, представляющих собой формальную
запись этого же алгоритма

Пример. Тождественнные преобразования строк в алфавите A — самоприменимый
алгоритм.


Теорема о проблеме останова MT. $\nexists $ алгоритма, способного по описанию произвольного
алгоритма и входных данных, определить, остановится ли алгоритм на этих данны




\section{Трудоемкость алгоритма. Функция трудоемкости.
Классификация алгоритмов по виду функции
трудоемкости.}

\subsection{Трудоёмкость алгоритма и её функция}


Определение. Трудоёмкость алгоритма — количество элементарных операций,
совершаемых алгоритмом для решения конкретной проблемы, заданной N + M + Sd + Sr
словами в памяти, где

 N — количество слов для описания проблемы

 M — программа-решение из M машинных инструкций

 Sd — память для хранения промежуточных результатов

 Sr — память для организации вычислительного процесса


Определение. Функция трудоёмкости $T_a$(N) — отношение, связывающее входные
данные алгоритма с количеством элементарных операций.
Комплексный анализ алгоритма может быть выполнен на основе комплексной оценки
ресурсов формальной системы, требуемых алгоритмом для решения конкретных проблем.
Очевидно, что для различных областей применения веса ресурсов будут различны, что
приводит к следующей комплексной оценке алгоритма:



\subsection{Классификация алгоритмов по виду функции трудоёмкости}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 215546.png}
\end{figure}



\section{Асимптотический анализ сложности алгоритмов;
сравнение наилучших, средних и наихудших
оценок; O-, o-, $\omega -$ и $\theta$-нотации. Свойства.}

\subsection{O-, Theta-, Omega-нотации}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 215739.png}
\end{figure}


\subsection{Свойства асимтотических оценок}


\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 215826.png}
\end{figure}


\section{Порядок роста. Основные классы эффективности}

\subsection{Порядок роста
}


\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 220051.png}
\end{figure}

\subsection{Основные классы эффективности}


9.2.1 Класс 0
Это класс быстрых алгоритмов с постоянным временем выполенния из функция
трудомекости O(1). Промежуточное состояние занимают алгоритмы со сложностью O(log n)

9.2.2 Класс P

Задачи со сложностью O(1):

 вставка и удаление элемента в односвязном и двусявязном списке

 добавление вершины или ребра в графе

Задачи со соложностью O(log n):

 Двоичный поиск в линейном упорядоченном массиве;

Задачи с полиномиальной сложностью:

 Задача сортировки

 Задача поиска эйлерова цикла на графе

9.2.3 Класс E

Класс экспоненциальных алгоритмов со степенью трудоёмкости O(2
n)

 Задача коммивояжёра

9.2.4 Класс F

Класс надэкспоненциальных алгоритмов с факториаьлной трудоёмкостью


\section{Класс NP. Проблема равенства P и NP. Класс NPС}

\subsection{Класс NP
}


Класс NP включает в себя четыре вида задач:

 Задачи, которые нельзя отнести ни к классу P, ни к классу E

 Задачи, которые недетерменированная машина Тьюринага может решить за
полиномиальное время, тогда как для детерменированной машины Тьюринга
полиномиальный алгоритм неизвестен.

 Для этих задач до сих пор не разрабботан эффективный (т. е. полиномиальный) алгоритм,
но и не доказано, что таких алгоритмов не существует.

 К классу NP относятся все задачи, решение которых можно проверить за полиномиальное
время. Проверка осуществляется следующим образом: абстрактная сущность — оракул —
предлагает решения, которые после проверки верификатором за полиномиальное время
приобретают “юридическую” силу


\subsection{Проблема равенства P и NP}

Поскольку детерминированная машина Тьюринга может рассматриваться как специальный
случай недетерминированной машины Тьюринга, в которой отсутствует стадия угадывания,
а стадия проверки совпадает с ДМТ, класс NP включает в себя класс P, а также некоторые
проблемы, для решения которых известны лишь алгоритмы, экспоненциально зависящие от
размера входа (то есть неэффективные для больших входов)

Вопрос о равенстве этих двух классов считается одной из самых сложных открытых
проблем в области теоретической информатики.

Доказательств нет, но считается, что p $\subset $ NP

\subsection{ Класс NPC
}


называется NP-полной (NPC).

Теорема. $\nexists $ полиномиально решаемая NPC-задача -> NPC = NP


\section{Анализ нерекурсивных алгоритмов по
фактическому количеству элементарных
операций. Анализ трудоемкости основных
алгоритмических конструкций.}


При анализе нерекурсинвых алгоритмов важно понимать, что они состоят из трёх основных
конструкций:

1. Следование, когда имеет место линейная последовательность. Трудоёмкость
вычисляется как сумма трудоёмкостей составных блоков: T = t1 + t2 + …

2. Ветвление, когда имеет место условное выполнение одного из нескольких блоков кода.
Оператор if можно представить в виде T = p * $t_{then}$ + (1 - p) * $t_{else}$, где p - вероятность
истинности условия.

3. Цикл, когда имеет место многократное выполнение одного и того же блока кода. В таком
случае трудоёмкость этого блока умножается на количество итераций.
Блоки могут представлять собой либо эти же конструкции (строя таким образом
вложенность), либо элементарные операции, которыми считаются:

1. Присваивание

2. Одномерная индексация

3. Арифметические операции

4. Сравнение

5. Логические операции

Трудоёмкость в данном подходе вычисляется как общее количество элементарных
операций.


\section{Оценивание порядков роста времени работы
нерекурсивных алгоритмов. Правило суммы и
произведения. Оценка основных
алгоритмических конструкций.}


\subsection{Правило суммы и произведения}

Правило сумм. T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))


Правило произведений. T1(n) * T2(n) = O(f(n) * g(n))


\subsection{Оценка основных алгоритмических конструкций}


Элементарные операции выполняются за O(1)

 Последовательность операций a, b, c выполняется за O(max(a, b, c))

 Условие выполняется за O(max(then, else))

 Цикл из n итераций над a выполняется за O(n * a)

\section{Анализ рекурсивных алгоритмов. Рекуррентные
соотношения. Метод индукции. Метод
подстановки.}



\subsection{Рекуррентные соотношения}

Анализ сложности состоит в определении трудоёмкости.
Определение. Рекуррентное соотношение — это уравнение или неравенство,
описывающее зависимость следующих значений от предыдущих.


\subsection{Метод индукции}


я его анализа по методу математической индукции мы находим мажорирующую
функцию f(n). Для этого мы предполгаем, что в базовом случае для достаточно большого $n_0$
неравенство выполняется, и выводим индуктивный шаг

\subsection{Метод
подстановки.
}

Метод подстановки состоит из трёх шагов:

1. Делается догадка о виде решения

2. С помощью метода математической индукции доказывается, что решение правильное

3. Вычисляются константы


\section{Анализ рекурсивных алгоритмов. Рекуррентные
соотношения. Первая основная теорема.
Следствие.}


\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 221728.png}
\end{figure}


\section{Математический анализ рекурсивных
алгоритмов. Рекуррентные соотношения. Вторая
основная теорема. Следствия.}


\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 222050.png}
\end{figure}



\section{Математический анализ рекурсивных
алгоритмов. Анализ дерева рекурсии.}

\begin{figure} [H]
  \centering
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-20 222050.png}
\end{figure}



\section{Эмпирический анализ алгоритмов.}


Эмпирический анализ алгоритмов — это метод оценки эффективности алгоритма на
практике путём проведения экспериментов и измерения его производительности на
различных входных данных. В отличие от теоретического (математического) анализа,
который даёт асимптотические оценки сложности, эмпирический анализ показывает
реальное поведение алгоритма в конкретных условиях.

Основные этапы эмпирического анализа алгоритмов:

 Определение цели эксперимента. Например, сравнить скорость работы нескольких
алгоритмов или проверить гипотезу о сложности.

 Выбор метрик измерения. Обычно измеряют время выполнения, количество операций,
использование памяти.

 Подготовка входных данных. Важно учитывать разные типы данных: случайные,
упорядоченные, худшие случаи, реальные данные.

 Реализация алгоритма и запуск тестов. Желательно использовать одинаковые условия
для всех алгоритмов (одинаковое оборудование, язык программирования, компилятор).

 Сбор и анализ результатов. На основе собранных данных строят графики, вычисляют
средние значения, делают выводы.


\section{Основные методы построения алгоритмов.
Алгоритмы «Разделяй и властвуй». Примеры.}





\section{}
\section{}
\section{}
\section{}
\section{}
\section{}


\section{}
\section{}
\section{}







\end{document}
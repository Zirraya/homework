\documentclass[bachelor, och, referat, times]{SCWorks}

% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен 


\input{preamble.sty}


%убирание преносов слов
\tolerance = 1
\emergencystretch = \maxdimen
\hbadness = 10000

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}
    
   % Кафедра (в родительном падеже)
    %\chair{математической кибернетики и компьютерных наук}
    \chair{информатики и программирования}
    % Тема работы
    \title{Анализ сложности для сортировок, не использующих сравнение элементов}
    
    % Курс
    \course{2}
    
    % Группа
    \group{211}
    
    % Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
    \department{факультета компьютерных наук и информационных технологий}
    
    % Специальность/направление код - наименование
    
    \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
    
    % Для студентки. Для работы студента следующая команда не нужна.
    \studenttitle{студентки}
    
    % Фамилия, имя, отчество в родительном падеже
    \author{Никитенко Яны Валерьевны}
    
    % Заведующий кафедрой 
    %\chtitle{доцент, к.\,ф.-м.\,н.}
    %\chname{С.\,В.\,Миронов}
    % Научный руководитель (для реферата преподаватель проверяющий работу)
    %\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
    %\saname{А.\,П.\,Грецова}
    % Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
    % \chpretitle{
    %     заведующий кафедрой математических основ информатики и олимпиадного\\
    %     программирования на базе МАОУ <<Ф"=Т лицей №1>>
    % }
    % \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
    % \chname{Кондратова\, Ю.\,Н.}
    \date{2025}
    
    
    % Руководитель практики от организации (руководитель для цифровой кафедры)
    %\patitle{доцент, к.\,ф.-м.\,н.}
    %\paname{С.\,В.\,Миронов}
    
    % Руководитель НИР
    %\nirtitle{доцент, к.\,п.\,н.} % степень, звание
    %\nirname{В.\,А.\,Векслер}
    
    % Семестр (только для практики, для остальных типов работ не используется)
    %\term{2}
    
    % Наименование практики (только для практики, для остальных типов работ не
    % используется)
    %\practtype{учебная}
    
    % Продолжительность практики (количество недель) (только для практики, для
    % остальных типов работ не используется)
    %\duration{2}
    
    % Даты начала и окончания практики (только для практики, для остальных типов
    % работ не используется)
    %\practStart{01.07.2022}
    %\practFinish{13.01.2023}
    
    % Год выполнения отчета
   
    
    \maketitle

    
    
    % Включение нумерации рисунков, формул и таблиц по разделам
    % (по умолчанию - нумерация сквозная)
    % (допускается оба вида нумерации)
    %\secNumbering

    
    
   
    
    % Раздел "Обозначения и сокращения". Может отсутствовать в работе
    %\abbreviations
    %\begin{description}
    %    \item $|A|$  "--- количество элементов в конечном множестве $A$;
    %    \item $\det B$  "--- определитель матрицы $B$;
    %    \item ИНС "--- Искусственная нейронная сеть;
    %    \item FANN "--- Feedforward Artifitial Neural Network
    %\end{description}
    
    % Раздел "Определения". Может отсутствовать в работе
    %\definitions
    
    % Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
    % Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
    %\defabbr
    

    \section{Сортировка подсчетом}
    \subsection{Текст программы}


    \begin{verbatim}
    // Функция сортировки
vector<int> countSort(vector<int>& inputArray)
{
    int N = inputArray.size();
    int M = 0; // Нахождение максимального элемента массива inputArray[]. 

    for (int i = 0; i < N; i++)
        M = max(M, inputArray[i]);

   
    vector<int> countArray(M + 1, 0); // Массив  запоненный нулями для хранения 
    всех вхождений входного массива

    //
    for (int i = 0; i < N; i++)      // Элементы из ввода сопоставленны с индексами
        countArray[inputArray[i]]++;
    //

    //
    for (int i = 1; i <= M; i++)            // Выичсиление суммы префикса 
    по каждому индексу
        countArray[i] += countArray[i - 1];
    //

    // Создания массива вывода
    vector<int> outputArray(N);

    for (int i = N - 1; i >= 0; i--) {
        outputArray[countArray[inputArray[i]] - 1]
            = inputArray[i];

        countArray[inputArray[i]]--;
    }
    return outputArray;
    //
}
//
 \end{verbatim}


 \subsection{Анализ сложности}
 Инициализация массива output происходит за время O(n), потому что размер массива равен n.
Инициализация массива count происходит за время O(1), потому что размер массива фиксирован и равен 10.
Первый цикл, который заполняет массив count, работает за O(n), где n – количество элементов.

Второй цикл, который преобразует массив count в префиксную сумму, работает за O(1) 
(поскольку размер массива фиксирован, равен 10).
Третий цикл, который заполняет массив output, работает за O(n).
Копирование временного массива output в исходный массив arr происходит за O(n)
Таким образом, общая временная сложность составляет: O(n) + O(1) + O(n) + O(n+k) + O(n) = O(n+k)

\section{Поразрядная сортировка (LSD)}
\subsection{Текст программы}

\begin{verbatim}

// Функция для получения максимального элемента в массиве
int getMax(const vector<int>& arr) {
    return *max_element(arr.begin(), arr.end());
}
//

// Функция для сортировки массива по разряду
void countingSort(vector<int>& arr, int exp) {

    int n = arr.size();
    vector<int> output(n); // Временный массив 
    для хранения отсортированных элементов
    int count[10] = { 0 }; // Массив для подсчета вхождений (0-9)

    // Подсчет вхождений для текущего разряда
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
    //

    // Изменение count[i], чтобы count[i] 
    содержал позицию этого разряда в output
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    //

    // Выходной массив
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    //

    // Копирование отсортированных элементов обратно в массив
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
    //
}
//

// Основная функция поразрядной сортировки
void radixSort(vector<int>& arr) {
    int maxVal = getMax(arr); // Нахождение максимального элемента
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        countingSort(arr, exp);
    }
}
//

 \end{verbatim}

 \subsection{Анализ сложности}

 1.Инициализация переменных:
 - Инициализация переменной n равна O(1), так как она зависит только от размера вектора vec.
 -  Инициализация переменной max итерируется по всем элементам вектора vec, следовательно, это займет O(n) времени.
2.Внешний цикл сортировки по разрядам:
 - Внешний цикл выполняется для каждого разряда числа, который оценивается как O(k), где k - количество разрядов в максимальном числе

3.Внутренние циклы:
 - Внутри внешнего цикла выполняются четыре внутренних цикла, каждый из которых имеет сложность O(n). Таким образом, общая сложность внутренних циклов составляет O(4n), что можно сократить до O(n).
Итак, общая временная сложность алгоритма равна сумме сложностей всех его частей:
O(1) + O(n) + O(k) * O(n) = O(kn)


Если количество разрядов большое, то сложность будет квадратичная. 
Если количество разрядов мало, то сложность будет линейная.




    \appendix
     
\end{document}
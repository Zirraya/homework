\documentclass[bachelor, och, referat, times]{SCWorks}

% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен 


\input{preamble.sty}


%убирание преносов слов
\tolerance = 1
\emergencystretch = \maxdimen
\hbadness = 10000

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}
    
   % Кафедра (в родительном падеже)
    %\chair{математической кибернетики и компьютерных наук}
    \chair{информатики и программирования}
    % Тема работы
    \title{Анализ двоичного дерева поиска}
    
    % Курс
    \course{2}
    
    % Группа
    \group{211}
    
    % Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
    \department{факультета компьютерных наук и информационных технологий}
    
    % Специальность/направление код - наименование
    
    \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
    
    % Для студентки. Для работы студента следующая команда не нужна.
    \studenttitle{студентки}
    
    % Фамилия, имя, отчество в родительном падеже
    \author{Никитенко Яны Валерьевны}
    
    % Заведующий кафедрой 
    %\chtitle{доцент, к.\,ф.-м.\,н.}
    %\chname{С.\,В.\,Миронов}
    % Научный руководитель (для реферата преподаватель проверяющий работу)
    %\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
    %\saname{А.\,П.\,Грецова}
    % Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
    % \chpretitle{
    %     заведующий кафедрой математических основ информатики и олимпиадного\\
    %     программирования на базе МАОУ <<Ф"=Т лицей №1>>
    % }
    % \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
    % \chname{Кондратова\, Ю.\,Н.}
    \date{2025}
    
    
    % Руководитель практики от организации (руководитель для цифровой кафедры)
    %\patitle{доцент, к.\,ф.-м.\,н.}
    %\paname{С.\,В.\,Миронов}
    
    % Руководитель НИР
    %\nirtitle{доцент, к.\,п.\,н.} % степень, звание
    %\nirname{В.\,А.\,Векслер}
    
    % Семестр (только для практики, для остальных типов работ не используется)
    %\term{2}
    
    % Наименование практики (только для практики, для остальных типов работ не
    % используется)
    %\practtype{учебная}
    
    % Продолжительность практики (количество недель) (только для практики, для
    % остальных типов работ не используется)
    %\duration{2}
    
    % Даты начала и окончания практики (только для практики, для остальных типов
    % работ не используется)
    %\practStart{01.07.2022}
    %\practFinish{13.01.2023}
    
    % Год выполнения отчета
   
    
    \maketitle

    
    
    % Включение нумерации рисунков, формул и таблиц по разделам
    % (по умолчанию - нумерация сквозная)
    % (допускается оба вида нумерации)
    %\secNumbering

    
    
   \tableofcontents
    
    % Раздел "Обозначения и сокращения". Может отсутствовать в работе
    %\abbreviations
    %\begin{description}
    %    \item $|A|$  "--- количество элементов в конечном множестве $A$;
    %    \item $\det B$  "--- определитель матрицы $B$;
    %    \item ИНС "--- Искусственная нейронная сеть;
    %    \item FANN "--- Feedforward Artifitial Neural Network
    %\end{description}
    
    % Раздел "Определения". Может отсутствовать в работе
    %\definitions
    
    % Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
    % Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
    %\defabbr
    

    \section{Текст программы}
    
    \begin{verbatim}
   
//
struct node {
	int key;
	node* left;
	node* right;
	node(int k) : key(k), left(nullptr), right(nullptr) {}
};

//

HANDLE outp = GetStdHandle(STD_OUTPUT_HANDLE);
CONSOLE_SCREEN_BUFFER_INFO csbInfo;
node* root = nullptr;

void max_height(node* x, short& max, short deepness = 1) 
{ // требует проверки на существование корня
	if (deepness > max) max = deepness;
	if (x->left) max_height(x->left, max, deepness + 1);
	if (x->right) max_height(x->right, max, deepness + 1);
}
bool isSizeOfConsoleCorrect(const short& width, const short& height) {
	GetConsoleScreenBufferInfo(outp, &csbInfo);
	COORD szOfConsole = csbInfo.dwSize;
	if (szOfConsole.X < width && szOfConsole.Y < height) 
    cout << "Please increase the height and width of the terminal. ";
	else if (szOfConsole.X < width) cout << "Please increase the width of the terminal. ";
	else if (szOfConsole.Y < height) cout << "Please increase the height of the terminal. ";
	if (szOfConsole.X < width || szOfConsole.Y < height) {
		cout << "Size of your terminal now: " << szOfConsole.X << ' ' << szOfConsole.Y
			<< ". Minimum required: " << width << ' ' << height << ".\n";
		return false;
	}
	
		return true;
}

void print_helper(node* x, const COORD pos, const short offset) {
	SetConsoleCursorPosition(outp, pos);
	cout << setw(offset + 1) << x->key;
	if (x->left) print_helper(x->left, { pos.X, short(pos.Y + 1) }, offset >> 1);
	if (x->right) print_helper(x->right, { short(pos.X + offset), short(pos.Y + 1) }, offset >> 1);
}

void print() {
	if (root) {
		short max = 1;
		max_height(root, max);
		short width = 1 << max + 1, max_w = 128; // вычисляем ширину вывода
		if (width > max_w) width = max_w;
		while (!isSizeOfConsoleCorrect(width, max)) system("pause");
		for (short i = 0; i < max; ++i) cout << '\n'; // резервируем место для вывода
		GetConsoleScreenBufferInfo(outp, &csbInfo); // получаем данные
		COORD endPos = csbInfo.dwCursorPosition;
		print_helper(root, { 0, short(endPos.Y - max) }, width >> 1);
		SetConsoleCursorPosition(outp, endPos);
		SetConsoleTextAttribute(outp, 7);
	}
}



// Добавить узел
void insert(node*& root, int key) {
    if (!root) {
        root = new node(key);
    }
    else if (key < root->key) {
        insert(root->left, key);
    }
    else {
        insert(root->right, key);
    }
}
//

// Найти 
node* findMin(node* root) {
    while (root && root->left) {
        root = root->left;
    }
    return root;
}
//

// Удалить узел
node* deleteNode(node* root, int key) {
    if (!root) return root;
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    }
    else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    }
    else {
        if (!root->left) {
            node* temp = root->right;
            delete root;
            return temp;
        }
        else if (!root->right) {
            node* temp = root->left;
            delete root;
            return temp;
        }
        node* temp = findMin(root->right);
        root->key = temp->key;
        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}
//

// Поиск
node* search(node* root, int key) {
    if (!root || root->key == key) return root;
    if (key < root->key) return search(root->left, key);
    return search(root->right, key);
}
//

// Обход в прямом порядке
void inorder(node* root) {
    if (root) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);

    }
}
//

// Обход в симметричном порядке
void preorder(node* root) {
    if (root) {
        cout << root->key << " ";
        preorder(root->left);
        preorder(root->right);
    }
}
//

// Обход в обратном порядке
void postorder(node* root) {
    if (root) {
        postorder(root->left);
        postorder(root->right);
        cout << root->key << " ";
    }
}
//

// Меню
void menu() {
    cout << "1. Добавить узел\n";
    cout << "2. Удалить узел\n";
    cout << "3. Поиск узла\n";
    cout << "4. Обход в прямом порядке\n";
    cout << "5. Обход в симметричном порядке\n";
    cout << "6. Обход в обратном порядке\n";
    cout << "7. Вывести дерево\n";
    cout << "0. Выход\n";
}
//

int main() {
    setlocale(LC_ALL, "Russian");
    int choice, key;
    while (true) {
        menu();
        cout << "Выберите действие: ";
        cin >> choice;

        switch (choice) {
        case 1:
            while (true) {
                cout << "-1 - выход из цикла" << endl;
                cin >> key;
                if (key == -1) break; // Выход из цикла добавления
                insert(root, key);
            }
            break;

        case 2:
            cout << "ключ для удаления: ";
            cin >> key;
            root = deleteNode(root, key);
            break;
        case 3:
            cout << "ключ для поиска: ";
            cin >> key;
            if (search(root, key)) {
                cout << "узел с ключом " << key << " найден.\n";
            }
            else {
                cout << "узел с ключом " << key << " не найден.\n";
            }
            break;
        case 4:
            cout << "обход в прямом порядке: ";
            preorder(root);
            cout << endl;
            break;
        case 5:
            cout << "обход в симметричном порядке: ";
            inorder(root);
            cout << endl;
            break;
        case 6:
            cout << "обход в обратном порядке: ";
            postorder(root);
            cout << endl;
            break;
        case 7:
            print();
            break;
        case 0:
            return 0;
        default:
            cout << "\n";
        }
    }
    return 0;
}
 \end{verbatim}


 \section{Анализ случаев}

\textbf{Лучший случай} 

Идеально сбалансированное дерево. Высота такого дерева равна $\lceil \log_2(n+1) \rceil$ или $O(\log n)$, где $n$ — количество элементов в дереве.

\textbf{Худший случай} 

Вырожденное дерево (вытянутое в цепочку). Высота такого дерева равна $n$, где $n$ — количество элементов.

\textbf{Средний случай} 

Для случайно построенного дерева ожидаемая высота составляет $O(\log n)$.

\section{Вставка в двоичном дереве}

\textbf{Лучший случай} 

$O(\log n)$ — вставка в сбалансированное дерево.

\textbf{Средний случай} 

$O(\log n)$ — для случайных данных.

\textbf{Худший случай} 

$O(n)$ — вставка в вырожденное дерево.

Математически сложность вставки определяется высотой дерева, так как алгоритм проходит путь от корня до места вставки.



 \section{Удаление в двоичном дереве}

\textbf{Лучший случай} 

$O(\log n)$ — удаление листа в сбалансированном дереве.

\textbf{Средний случай} 

$O(\log n)$.

\textbf{Худший случай} 

$O(n)$ — удаление в вырожденном дереве.

При удалении узла с двумя потомками требуется найти минимальный элемент в правом поддереве (операция за $O(h)$), что не меняет асимптотическую сложность.
 

  \section{Поиск в двоичном дереве}


\textbf{Лучший случай} 

$O(1)$ — если искомый элемент находится в корне.

\textbf{Средний случай} 

$O(\log n)$ — для сбалансированного дерева.

\textbf{Худший случай} 

$O(n)$ — для вырожденного дерева.


  \section{Обходы дерева}

  Все три типа обхода (прямой, симметричный, обратный) имеют сложность:
$$O(n)$$
где $n$ — количество узлов в дереве, так как каждый узел посещается ровно один раз.

  \section{Расход памяти}


 Память, потребляемая двоичным деревом поиска:
\begin{itemize}
    \item Каждый узел содержит: значение (4 байта для int) + 2 указателя (8 байт каждый на 64-битной системе)
    \item Общий размер узла: $4 + 8 + 8 = 20$ байт
    \item Общая память для $n$ узлов: $O(n)$
\end{itemize}

Дополнительная память для рекурсивных операций (в худшем случае): $O(h)$, где $h$ — высота дерева.





    \appendix
     
\end{document}
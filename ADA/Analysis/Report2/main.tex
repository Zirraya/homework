\documentclass[bachelor, och, referat, times]{SCWorks}

% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен 


\input{preamble.sty}


%убирание преносов слов
\tolerance = 1
\emergencystretch = \maxdimen
\hbadness = 10000

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}
    
   % Кафедра (в родительном падеже)
    %\chair{математической кибернетики и компьютерных наук}
    \chair{информатики и программирования}
    % Тема работы
    \title{Анализ сложности быстрой и пирамидальной сортировок}
    
    % Курс
    \course{2}
    
    % Группа
    \group{211}
    
    % Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
    \department{факультета компьютерных наук и информационных технологий}
    
    % Специальность/направление код - наименование
    
    \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
    
    % Для студентки. Для работы студента следующая команда не нужна.
    \studenttitle{студентки}
    
    % Фамилия, имя, отчество в родительном падеже
    \author{Никитенко Яны Валерьевны}
    
    % Заведующий кафедрой 
    %\chtitle{доцент, к.\,ф.-м.\,н.}
    %\chname{С.\,В.\,Миронов}
    % Научный руководитель (для реферата преподаватель проверяющий работу)
    %\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
    %\saname{А.\,П.\,Грецова}
    % Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
    % \chpretitle{
    %     заведующий кафедрой математических основ информатики и олимпиадного\\
    %     программирования на базе МАОУ <<Ф"=Т лицей №1>>
    % }
    % \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
    % \chname{Кондратова\, Ю.\,Н.}
    \date{2025}
    
    
    % Руководитель практики от организации (руководитель для цифровой кафедры)
    %\patitle{доцент, к.\,ф.-м.\,н.}
    %\paname{С.\,В.\,Миронов}
    
    % Руководитель НИР
    %\nirtitle{доцент, к.\,п.\,н.} % степень, звание
    %\nirname{В.\,А.\,Векслер}
    
    % Семестр (только для практики, для остальных типов работ не используется)
    %\term{2}
    
    % Наименование практики (только для практики, для остальных типов работ не
    % используется)
    %\practtype{учебная}
    
    % Продолжительность практики (количество недель) (только для практики, для
    % остальных типов работ не используется)
    %\duration{2}
    
    % Даты начала и окончания практики (только для практики, для остальных типов
    % работ не используется)
    %\practStart{01.07.2022}
    %\practFinish{13.01.2023}
    
    % Год выполнения отчета
   
    
    \maketitle

    
    
    % Включение нумерации рисунков, формул и таблиц по разделам
    % (по умолчанию - нумерация сквозная)
    % (допускается оба вида нумерации)
    %\secNumbering

    
    
   \tableofcontents
    
    % Раздел "Обозначения и сокращения". Может отсутствовать в работе
    %\abbreviations
    %\begin{description}
    %    \item $|A|$  "--- количество элементов в конечном множестве $A$;
    %    \item $\det B$  "--- определитель матрицы $B$;
    %    \item ИНС "--- Искусственная нейронная сеть;
    %    \item FANN "--- Feedforward Artifitial Neural Network
    %\end{description}
    
    % Раздел "Определения". Может отсутствовать в работе
    %\definitions
    
    % Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
    % Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
    %\defabbr
    

    \section{Быстрая сортировка}
    \subsection{Текст программы}


    \begin{verbatim}
   //  Для опорного элемента и разделеения массива элемента
int partition(vector<int>& arr, int low, int high) {

    
    int pivot = arr[high]; // Выбор опорной точки

   
    int i = low - 1; // Индекс наименшьего элемента распологается 
    справа от опорного элемнта

        // Прохождение arr[low..high] и перемещещние все меньших
       // элементы слева. Элементы от low до  high
       // i уменьшается после каждой итерации
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[i + 1], arr[high]); // Передвижение опорного элемента 
    после меньших элементов
    return i + 1;   // Возвращение позиций 
}
//

// Функция быстрой сортировки
void quickSort(vector<int>& arr, int low, int high) {
    while (low < high) {
        int pi = partition(arr, low, high); // Возвращает индекс опорного элемента

        // Рекурсивные вызовы для меньших и больших элементов
        if (pi - low < high - pi) {
            quickSort(arr, low, pi - 1);
            low = pi + 1; // Избегаем переполнения стека
        }
        else {
            quickSort(arr, pi + 1, high);
            high = pi - 1; // Избегаем переполнения стека
        }
    }
}
//
 \end{verbatim}


 \subsection{Анализ сложности}
\begin{itemize}
    \item \textbf{Лучший случай} (сбалансированное разбиение):
    $$T(n) = 2T\left(\frac{n}{2}\right) + O(n)$$
    По основной теореме: $T(n) = O(n \log n)$

    \item \textbf{Худший случай} (несбалансированное разбиение):
    $$T(n) = T(n-1) + O(n)$$
    Решение: $T(n) = O(n^2)$

    \item \textbf{Средний случай}: $T(n) = O(n \log n)$
\end{itemize}

\textbf{Объяснение:}
\begin{itemize}
    \item Функция \texttt{partition()} имеет сложность $O(n)$, так как проходит по всем элементам подмассива один раз
    \item В лучшем случае массив делится пополам, создавая $\log n$ уровней рекурсии
    \item На каждом уровне выполняется работа $O(n)$, итого $O(n \log n)$
    \item В худшем случае глубина рекурсии $n$, на каждом уровне работа $O(n)$, итого $O(n^2)$
    \item В представленной реализации используется оптимизация хвостовой рекурсии, которая уменьшает глубину стека, но не меняет асимптотическую сложность
\end{itemize}



\section{Пирамидальная сортировка}
\subsection{Текст программы}

\begin{verbatim}
// Для создания кучи поддерева с корнем в узле i, который
// индекс в arr[]. n — размер кучи
void heapify(int arr[], int n, int i) {
    int largest = i; // Инициализируем наибольший элемент как корень
    int l = 2 * i + 1; // левый = 2*i + 1
    int r = 2 * i + 2; // правый = 2*i + 2

    // Если левый дочерний элемент больше корня
    if (l < n && arr[l] > arr[largest])
        largest = l;
    //

    // Если правый дочерний элемент больше, 
    чем наибольший элемент на данный момент
    if (r < n && arr[r] > arr[largest])
        largest = r;
    //

    // Если наибольший элемент не корень
    if (largest != i) {
        swap(arr[i], arr[largest]); // Перестановка
        heapify(arr, n, largest); // Рекурсивная группировка 
        соответствующего поддерево
    }
    //
}
//

// Основная функция сортировки кучи
void heapSort(int arr[], int n) {
    // Построение кучи (перегруппировка массива)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // Извлечение элементов из кучи
    for (int i = n - 1; i >= 0; i--) {
        swap(arr[0], arr[i]); // Перемещение текущего элемента

        // Вызов на усеньшенной куче
        heapify(arr, i, 0);
    }
}
//


 \end{verbatim}

 \subsection{Анализ сложности}

\textbf{Анализ функций:}

\begin{itemize}
    \item \textbf{Функция \texttt{heapify()}:}
    \begin{itemize}
        \item В худшем случае элемент "просеивается" от корня до листа
        \item Высота бинарной кучи: $O(\log n)$
        \item Сложность \texttt{heapify()}: $O(\log n)$
    \end{itemize}

    \item \textbf{Построение кучи:}
    \begin{itemize}
        \item Выполняется для элементов от $n/2-1$ до 0
        \item Суммарная сложность: $O(n)$
    \end{itemize}

    \item \textbf{Процесс сортировки:}
    \begin{itemize}
        \item Выполняется $n$ извлечений максимального элемента
        \item Каждое извлечение требует \texttt{heapify()} за $O(\log n)$
        \item Сложность: $n \times O(\log n) = O(n \log n)$
    \end{itemize}
\end{itemize}

\textbf{Общая сложность:}
$$T(n) = O(n) + O(n \log n) = O(n \log n)$$

\textbf{Особенности:}
\begin{itemize}
    \item Сложность всегда $O(n \log n)$ независимо от входных данных
    \item Не требует дополнительной памяти (in-place)
    \item Неустойчивая сортировка
\end{itemize}




    \appendix
     
\end{document}
\documentclass[bachelor, och, referat, times]{SCWorks}

% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен 


\input{preamble.sty}


%убирание преносов слов
\tolerance = 1
\emergencystretch = \maxdimen
\hbadness = 10000

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}
    
   % Кафедра (в родительном падеже)
    %\chair{математической кибернетики и компьютерных наук}
    \chair{информатики и программирования}
    % Тема работы
    \title{Оценка сложности префикс-функции, Z-функции и алгоритма КМП}
    
    % Курс
    \course{2}
    
    % Группа
    \group{211}
    
    % Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
    \department{факультета компьютерных наук и информационных технологий}
    
    % Специальность/направление код - наименование
    
    \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
    
    % Для студентки. Для работы студента следующая команда не нужна.
    \studenttitle{студентки}
    
    % Фамилия, имя, отчество в родительном падеже
    \author{Никитенко Яны Валерьевны}
    
    % Заведующий кафедрой 
    %\chtitle{доцент, к.\,ф.-м.\,н.}
    %\chname{С.\,В.\,Миронов}
    % Научный руководитель (для реферата преподаватель проверяющий работу)
    %\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
    %\saname{А.\,П.\,Грецова}
    % Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
    % \chpretitle{
    %     заведующий кафедрой математических основ информатики и олимпиадного\\
    %     программирования на базе МАОУ <<Ф"=Т лицей №1>>
    % }
    % \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
    % \chname{Кондратова\, Ю.\,Н.}
    \date{2025}
    
    
    % Руководитель практики от организации (руководитель для цифровой кафедры)
    %\patitle{доцент, к.\,ф.-м.\,н.}
    %\paname{С.\,В.\,Миронов}
    
    % Руководитель НИР
    %\nirtitle{доцент, к.\,п.\,н.} % степень, звание
    %\nirname{В.\,А.\,Векслер}
    
    % Семестр (только для практики, для остальных типов работ не используется)
    %\term{2}
    
    % Наименование практики (только для практики, для остальных типов работ не
    % используется)
    %\practtype{учебная}
    
    % Продолжительность практики (количество недель) (только для практики, для
    % остальных типов работ не используется)
    %\duration{2}
    
    % Даты начала и окончания практики (только для практики, для остальных типов
    % работ не используется)
    %\practStart{01.07.2022}
    %\practFinish{13.01.2023}
    
    % Год выполнения отчета
   
    
    \maketitle

    
    
    % Включение нумерации рисунков, формул и таблиц по разделам
    % (по умолчанию - нумерация сквозная)
    % (допускается оба вида нумерации)
    %\secNumbering

    
    
   \tableofcontents
    
    % Раздел "Обозначения и сокращения". Может отсутствовать в работе
    %\abbreviations
    %\begin{description}
    %    \item $|A|$  "--- количество элементов в конечном множестве $A$;
    %    \item $\det B$  "--- определитель матрицы $B$;
    %    \item ИНС "--- Искусственная нейронная сеть;
    %    \item FANN "--- Feedforward Artifitial Neural Network
    %\end{description}
    
    % Раздел "Определения". Может отсутствовать в работе
    %\definitions
    
    % Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
    % Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
    %\defabbr
    

    \section{Префикс-функция}
    \subsection{Текст программы}
       \begin{verbatim}
        // Префикс функция
vector<int> Prefix_Function(const string& s) {
    int n = s.length();
    vector<int> pi(n, 0); //вектор для хранения значений префикс-функции

    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1]; //длина предыдущего префикса

        //пока символы не совпадают и j больше 0, уменьшаем j
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }

        //если символы совпадают, увеличиваем j
        if (s[i] == s[j]) {
            j++;
        }

        pi[i] = j; //записываем значение префикс-функции
    }

    return pi;
}
//

 \end{verbatim}
    \subsection{Анализ}

 Инициализация переменной в строке 2 работает за константу. 
 Создание вектора в строке 3 работает за линию.
Далее цикл работает за n. 

Эта сложность умножается на сумму всех сложностей внутри цикла.

В худшем случае цикл while из строки  может работать O(n) раз за одну итерацию, 
но в среднем каждый while работает за O(1).
Остальные операции внутри внешнего цикла выполняются за константу. 
Префикс-функция каждый шаг возрастает максимум на единицу 
и после каждой итерации while уменьшается хотя бы на единицу.
Значит, суммарное количество операций:


$T = O(1) + O(n) + O(n) * (O(1) + O(1) + O(1) + O(1) + O(1)) \approx  O(n)$


\section{Z-функция}
\subsection{Текст программы}
\begin{verbatim}
    // Z функция
vector<int> Z_function(const std::string& s) {
    int n = s.length();
    std::vector<int> Z(n, 0);
    int L = 0, R = 0;

    for (int i = 1; i < n; ++i) {
        if (i > R) {
            L = R = i;
            while (R < n && s[R] == s[R - L]) {
                R++;
            }
            Z[i] = R - L;
            R--;
        }
        else {
            int k = i - L;
            if (Z[k] < R - i + 1) {
                Z[i] = Z[k];
            }
            else {
                L = i;
                while (R < n && s[R] == s[R - L]) {
                    R++;
                }
                Z[i] = R - L;
                R--;
            }
        }
    }
    return Z;
}
//
\end{verbatim}

\subsection{Анализ}
Инициализация переменных в 2 и 4 строки происходит за константу. Инициализация вектора в строке 3 работает за O(n).
Цикл в строке 5 работает за O(n), каждая операция внутри домножается
на O(n) по правилу умножения вложенных циклов.

В основном сложность алгоритма зависит от цикла . 

В алгоритме мы делаем столько же действий, сколько раз сдвигается правая граница z-блока
— а это O(n) в сумме по всем проходам цикла. Таким образом, 
в среднем на каждой итерации этот цикл будет работать за какую-то константу.
Общая сложность алгоритма таким образом составит:
$T = O(1) + O(n) + O(1) + O(n) · (O(1) + O(1) + O(1) + O(1) + O(1) +$
$O(1) + O(1)) + O(1) + O(1) = O(1) + O(n) + O(n)O(1) + O(1) \approx  O(n)$

\section{Алгоритм Кнута-Морриса Пратта (КМП)}

\subsection{Текст программы}
\begin{verbatim}

    // Префикс функция
vector<int> Prefix_Function(const string& s) {
    int n = s.length();
    vector<int> pi(n, 0); //вектор для хранения значений префикс-функции

    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1]; //длина предыдущего префикса

        //пока символы не совпадают и j больше 0, уменьшаем j
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }

        //если символы совпадают, увеличиваем j
        if (s[i] == s[j]) {
            j++;
        }

        pi[i] = j; //записываем значение префикс-функции
    }

    return pi;
}
//

    //
void KnutMorrisPratt(const string& text, const string& pattern) {
    vector<int> pi = Prefix_Function(pattern);
    int n = text.length();
    int m = pattern.length();
    int j = 0; // индекс для pattern

    for (int i = 0; i < n; i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = pi[j - 1]; // откат к предыдущему префиксу
        }
        if (text[i] == pattern[j]) {
            j++;
        }
        if (j == m) { // найдено совпадение
            cout << (i - m + 1) << endl;
            j = pi[j - 1]; // продолжаем поиск
        }
    }
}
//
\end{verbatim}

\subsection{Анализ}

Инициализация переменных в функции KnutMorrisPratt в строках 3-4 работает за $O(1)$.

 Инициализация вектора работает за $O(N )$.

Функция $Prefix_Function$ работает за линейное время $(O(N))$. 

Иницилизация переменной в строке 5 выполняется за константу.

Цикл for работает за O(N ).

Тогда общая временная сложность
$T = O(1) + O(N ) + O(M ) + O(N )O(1) = O(N ) + O(M ) = O(N + M ).$
Так как $M \leq  N$ , то можно сказать, 
что алгоритм работает не больше чем за $T = O(N + M ) \approx  O(2 * N ) = O(N )$.
    \appendix
     
\end{document}
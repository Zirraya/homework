\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage[english, russian] {babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{minted}
\usepackage{float}
\usepackage{amssymb}

\title{Языки программирования}
\author{silvia.lesnaia }


\begin{document}

\maketitle

\textbf{02.09.25}

\section{Введение}

Standard VML

Kastrell

List

Ruby

\section{Императивное программирование}

Предполагает что программе отдают команды, и компьютер последовательно
выполняет команды.

Пример: оператор присваивания


В высокоуровневом языке сложение двух чисел является операцией, когда же в низкоуровневым
же это будет являться оператором.


Нечистые функции получают выражение с побочным эффектом

Чистое выражение(функция) получает выражение без побочного эффекта


Первая парадигма программирования - Функциональная парадигма программирования

Является одной из разновидностей декаларативного программирования

Есть деклатированное программирование и императивное программирования

К деклатированному программированию относятся: Функциональное программирование,
логическое программирование.

Любая функция препдологает некоторые агрументы f $S_1*S_2*S_3...*S_4\rightarrow S$

Функцию называют \textbf{ЧИСТОЙ} если ее результат зависит от ее параметров, а не от 
внешней среды, кроме того при вычисление результата, функция не оставляет 
никаких побочных эффектов.

\section{Standard ML}

Пример: 

fun f (a : int, b : int) : int =

2*a+b

\vspace{5mm}

fun <имя функции> (аргументы) : тип результата = выражение

\vspace{3mm}



$\lambda$ - исчисление (это формализм)предполагает, что 

Используется для тезиса Черча


Пример 1:

fun f1(a : int, b : int, c : int) : int = 
= a*a*+b*b+c*c

Пример 2:

fun square(a: int) : int = a*a 

fun f1 (a : int, b : int, c : int) = square(a)+square(b)+square(b) 

\vspace{5mm}
let 

\hspace{5mm} декларация

in 

\hspace{5mm} выражение

end

\vspace{5mm}

let 

\hspace{2mm} val dx21 = x2-x1

\hspace{2mm} val dy21 = y2-y1

\hspace{2mm} val dx31 = x3-x1

\hspace{2mm} val dy31 = y3-y1

\hspace{2mm} val dy23 = y2-y3

\hspace{2mm} val dx23 = x2-x3

in 

dx21*dy21*dx31*dy31*dx23*dy23


\vspace{2mm}

 НИЧТО НЕ ДОЛЖНО ВЫЧИСЛЯИСЯ ДВАЖДЫ
 
 \vspace{2mm}

НЕ ДОЛЖНО БЫТЬ НЕ ОБОСНОВАННЫХ ОБОЗНАЧЕНИЙ И ИСПОЛЬЗОВАТЬ ХОТЯ БЫ ДВА РАЗА

\vspace{2mm}

\textbf{Затенение} 

val a = 5  \hspace{2mm} $a\leftarrow 5$

val a = 17 \hspace{2mm} $a\leftarrow 17$

\vspace{2mm}

val a=5

val b = let(b,28)

\hspace{15mm} val a = 17

\hspace{15mm} val b =17

in 

\hspace{15mm} $a+b \rightarrow 24$

----------------------------

\vspace{5mm}

val a = if b > 25 then 45 - b

\hspace{10mm} else 45 + b



Является язык строго типизированным, это означает что у выражение должен быть определен тип,
которое вернет выражение.

Конструкции цикла нет, будут использоваться рекурсия



\textbf{16.09.25}

Продолжение рекурсивных алгоритмов

Значение unit - () тип значение

Ввод:

val a = 5
 
val b = 7

val c = 9

\vspace{5mm}

Вывод:

val a = 5:unit
 
val b = 7:unit

val c = 9:unit

val d = () unit

Если нажать f5, то это будет воспринимаися как use $\Rightarrow ()$

\vspace{5mm}


fun f(l: a' list ): 'a = hd(tl(tl l)) // функция возвращает 
третий элемент, если конечно он есть


Полиморфные функции - может принимать различные типы данных, наличие этих функций
называется полиморфизмом.
В Standard ML есть полиморфизм по типам данным.


\vspace{5mm}

Сравниваем два элемента списка

fun f''(l:\hspace{10mm} ):  \hspace{10mm}    =

if null l then []

else if null (tl l) then l

else if hd l = (tl l)

then f''(tl l)

else if hd l :: f''(tl l )

\vspace{15mm}

\textbf{КАК ДЕЛАТЬ НЕ НАДО}

[1,2,3,4,5]$\Rightarrow$ [5,4,3,2,1]

fun reverse (l:'a list):'a list = 

if null l then l
\vspace{20mm}

\textbf{КАК НАДО}

fun reverse (l:'a list) :'a list = 

let

fun revhelper( l:'a list, ace : 'a list)

\hspace{50mm} :'a list

if null l then ace

else revhelper(tl l, hd l:: ace)

in 

revhelper(l,[])

end

\vspace{10mm}

\textbf{23.09.25}

\section{Контейнеры. Объявления собственных типов данных}

Контейнер 

int \hspace{20mm}real

int list \hspace{15mm}[1,2,3]

real optom \hspace{10mm}SOME 3.15

            \hspace{25mm}NONE

date \hspace{10mm}= int * int * int

1. Определение синонимов типов данных 

person = {name : string, age : int, num : int, salary : real, l : 'a list}

v : int person

2. Определение контейнеров


datatype эта конструкция определяет новый тип данных

color имя типа

datatype color = RED | BLUE | WHITE

\hspace{27mm} | ORANGE | BLACK

\hspace{27mm} конструкторы


\section{Механизм сопоставления с шаблоном}

Сопостовление с образцом или размещение по шаблону. 

d : date 

val (day, moth, year) = d 

val (a1,a2,a3) = (b1,b2,b3)

Шаблон может содеражть:

конструкторы

идентифиакторы

джокер / whildcard или же нижнее подчеркивание

<шаблон> as

\textbf{07.10.25}

\section{Динмическое окражение}

Динамическое окружение  это совокувнуть занчений свзяных имен в момент выполнения конкрнетной инструкции 
програмного кода.

Для приера мы будем его предтсявлять как список связанх значений. Каждый элемент пара, первый элемент 
имя, второй заненчеие.

[(имя,занчение),.......]

[(a,25),(6,13),(c,28), (a,13)]

a+b-c

25+13-78

\subsection{Формирование динамического окружения}

1. val a =13

2. val b = 11

3. val c =8

4. val a = 25

5. val d = let val a = 2

\hspace{15mm} val b =8 

\hspace{15mm}  in a+b -c

\hspace{15mm}  end

6. fun f(a,x) = a+x-c 

7. fun g(a,x) = if a>0 then 2+f(a-2,x*2) else 1

8. val e = f(a,b)

9. val h = g(7,3)


Парметры которые использвуются при описании функции называются формальными ппараметрами.

Параметры которые исполбзуются при вызове функции назюыатся ффактическими прарметрами. В строке 
8 фактические параметры. 

Замыкание функции это сосвокунапоть определинии функции вместе с динмаеическим окружением, в которм 
она была определена

Статсичекое окружение при привдеротильеном анлазие программы, при выполнении оно не нужно.



\textbf{14.10.25}


\section{Модель нормальных вычислений}

тут пикча 


\section{Карированные функции}

До этоого мы функции определяли как:

тут пикча



Сигнатурой функцие называется сочетания типов параматеров с результатом функции,
по сути  типо значения функции.


тут новая пикча

Разница между сигнатурой g' и g нету разнице.


тут пикча


\textbf{Карирование} предпологает, что если у нас есть функции от трех параметорв кортежа,
то вы полчучаете функцию которая выддает первый параметр, второй, третий, а 
потом кортеж.

тут пикча


Обратный процесс 

\textbf{Декарирование, или анкорирование}



\textbf{21.10.25}

fun zip  x= x*25

val a =f 

fun g1 x =fx

\begin{itemize}
    \item Двумерный синтаксис
    \item Ленивые вычисления
    \item Меморизация - сохранение памяти 
\end{itemize}

\textbf{28.10.25}

\section{Бесконечные списки}

СГНФ - вычселеена с точностью до конструктора.

\textbf{SML}    \hspace{20mm}     \textbf{Haskell}

datatype \hspace{5mm}    = \hspace{5mm}   data

'a list 

::  []     \hspace{25mm}    : []

Функция геттер позволяет извлекать данные из конструкции 

Сеттер - изменить в заданной структуре данных на другое значение

\vspace{10mm}

\textbf{11.11.25}

clear show (a) where MIME -type

show :: a->string 



Охранное выражения 


\end{document}
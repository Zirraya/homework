\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен 
%убирание преносов слов
\tolerance = 1
\emergencystretch = \maxdimen
\hbadness = 10000

\usepackage{listings}
\input{preamble.sty}


\lstset{
    language=[Sharp]C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    frame=single,
    tabsize=4,
    showstringspaces=false
}
\begin{document}
    
   % Кафедра (в родительном падеже)
    %\chair{математической кибернетики и компьютерных наук}
    \chair{информатики и программирования}
    % Тема работы
    \title{Теория графов в 2025}
    
    % Курс
    \course{3}
    
    % Группа
    \group{311}
    
    % Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
    \department{факультета компьютерных наук и информационных технологий}
    
    % Специальность/направление код - наименование
    
    \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
    
    % Для студентки. Для работы студента следующая команда не нужна.
    \studenttitle{студентки}
    
    % Фамилия, имя, отчество в родительном падеже
    \author{Никитенко Яны Валерьевны}

    % Заведующий кафедрой
\chtitle{доцент, к. ф.-м. н.} % степень, звание
\chname{М.\,В.\,Огнева}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{с.п, кафедры информатики и программирования} %должность, степень, звание
\saname{М.\,С.\,Портенко}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{доцент, к. ф.-м. н.} 
\paname{С.\,В.\,Миронов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{5}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Семестр (только для практики, для остальных
% типов работ не используетс
    
    % Заведующий кафедрой 
    %\chtitle{доцент, к.\,ф.-м.\,н.}
    %\chname{С.\,В.\,Миронов}
    % Научный руководитель (для реферата преподаватель проверяющий работу)
    %\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
    %\saname{А.\,П.\,Грецова}
    % Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
    % \chpretitle{
    %     заведующий кафедрой математических основ информатики и олимпиадного\\
    %     программирования на базе МАОУ <<Ф"=Т лицей №1>>
    % }
    % \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
    % \chname{Кондратова\, Ю.\,Н.}
    \date{2025}
    
    
    % Руководитель практики от организации (руководитель для цифровой кафедры)
    %\patitle{доцент, к.\,ф.-м.\,н.}
    %\paname{С.\,В.\,Миронов}
    
    % Руководитель НИР
    %\nirtitle{доцент, к.\,п.\,н.} % степень, звание
    %\nirname{В.\,А.\,Векслер}
    
    % Семестр (только для практики, для остальных типов работ не используется)
    %\term{2}
    
    % Наименование практики (только для практики, для остальных типов работ не
    % используется)
    %\practtype{учебная}
    
    % Продолжительность практики (количество недель) (только для практики, для
    % остальных типов работ не используется)
    \duration{2}
    
    % Даты начала и окончания практики (только для практики, для остальных типов
    % работ не используется)
    \practStart{01.09.2025}
    \practFinish{31.12.2025 }
    
    % Год выполнения отчета
   
    
    \maketitle

    
    % Включение нумерации рисунков, формул и таблиц по разделам
    % (по умолчанию - нумерация сквозная)
    % (допускается оба вида нумерации)
    %\secNumbering

    
    
    \tableofcontents
    
    % Раздел "Обозначения и сокращения". Может отсутствовать в работе
    %\abbreviations
    %\begin{description}
    %    \item $|A|$  "--- количество элементов в конечном множестве $A$;
    %    \item $\det B$  "--- определитель матрицы $B$;
    %    \item ИНС "--- Искусственная нейронная сеть;
    %    \item FANN "--- Feedforward Artifitial Neural Network
    %\end{description}
    
    % Раздел "Определения". Может отсутствовать в работе
    %\definitions
    
    % Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
    % Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
    %\defabbr
    
    
    % Раздел "Введение"
   \section{Класс Граф}
    \subsection{Задание}

    Для решения всех задач курса необходимо создать класс 
    (или иерархию классов - на усмотрение разработчика), содержащий:

1. Структуру для хранения списка смежности графа 
(не работать с графом через матрицы смежности, 
если в некоторых алгоритмах удобнее использовать список ребер - реализовать метод, 
создающий список рёбер на основе списка смежности);

2. Конструкторы (не менее 3-х):

конструктор по умолчанию, создающий пустой граф
конструктор, заполняющий данные графа из файла
конструктор-копию (аккуратно, не все сразу делают именно копию)
специфические конструкторы для удобства тестирования

3. Методы:

- добавляющие вершину,

- добавляющие ребро (дугу),

- удаляющие вершину,

- удаляющие ребро (дугу),

- выводящие список смежности в файл (в том числе в пригодном для чтения конструктором формате).

Не выполняйте некорректные операции, сообщайте об ошибках.

4. Должны поддерживаться как ориентированные, так и неориентированные графы. 
Заранее предусмотрите возможность добавления меток и$\backslash$или весов для дуг. 
Поддержка мультиграфа не требуется.

5. Добавьте минималистичный консольный интерфейс пользователя 
(не смешивая его с реализацией!), позволяющий добавлять и удалять вершины и рёбра (дуги) 
и просматривать текущий список смежности графа.

6. Сгенерируйте не менее 4 входных файлов с разными типами графов 
(балансируйте на комбинации ориентированность-взвешенность) 
для тестирования класса в этом и последующих заданиях. 
Графы должны содержать не менее 7-10 вершин, в том числе петли и изолированные вершины.

\subsection{Реализация}

1. Реализация класса Graph1 и его основных методов:

Структура класса - приватные поля:

Dictionary<int, List<Edge>> adjacencyList - список смежности

bool IsDirected - флаг ориентированности графа

bool IsWeighted - флаг взвешенности графа

2. Конструкторы:

По умолчанию (создает пустой граф с указанной направленностью и взвешенностью)

Из файла (загружает граф из указанного файла)

Копирования (создает копию существующего графа)

Из списка рёбер (для тестирования)

Из матрицы смежности (для тестирования)

3. Методы проверки:

ContainsVertex() - проверяет существование вершины

ContainsEdge() - проверяет существование ребра

4. Методы модификации графа:

AddVertex() - добавляет новую вершину

AddEdge() - добавляет новое ребро (с весом или без)

RemoveVertex() - удаляет вершину и все связанные с ней рёбра

RemoveEdge() - удаляет указанное ребро

5. Методы работы с файлами и вывода:

SaveToFile() - сохраняет граф в файл в формате:

text

directed/undirected weighted/unweighted

вершина1: смежная вершина вес...

вершина 2: ...


Конструктор Graph(string filename) - загружает граф из файла аналогичного формата

GetEdgeList() - возвращает список всех рёбер графа в виде кортежей (from, to, weight)

GetAdjacencyListString() - возвращает строковое представление списка смежности

6. Дополнительные методы:

GetVertices() - возвращает список всех вершин

GetAdjacentVertices() - возвращает список смежных вершин для указанной вершины

VertexCount - свойство, возвращающее количество вершин

EdgeCount - свойство, возвращающее количество рёбер

7. Вложенный класс Edge:

Target - целевая вершина ребра

Weight - вес ребра (по умолчанию 1.0)

Особенности реализации:

\begin{itemize}
\item Поддержка как ориентированных, так и неориентированных графов

\item Поддержка как взвешенных, так и невзвешенных графов

\item Автоматическое добавление обратных рёбер для неориентированных графов

\item Проверка на существование вершин и рёбер перед операциями

\item Обработка исключительных ситуаций при работе с файлами

\item Запрет петель в неориентированных графах
\end{itemize}

Ограничение: граф не является мультиграфом (ребра уникальны)

Формат файла для сохранения/загрузки:

text

[тип графа] [взвешенность]

вершина1: смежная вершина вес...

вершина 2: ...

Пример:

text

undirected weighted

23: 27 7, 79 10

27: 23 7, 80 5

36: 80 1

57: 80 2

70: 79 1, 80 3

79: 23 10, 70 1

80: 27 5, 36 1, 57 2, 70 3


   
Все задания данной практики выполнены на языке программирования

С\#. Далее представлен программный код класса Graph1.
\inputminted{csharp}{Код/Graph.cs}



\section{Консольный интерфейс}

Консольный интерфейс реализует взаимодействие пользователя с графом
через меню с 9 основными операциями: добавление/удаление вершин и рёбер,
вывод графа, сохранение и загрузка из файла, показ информации о графе. 
Программа работает в бесконечном 
цикле до выбора опции выхода.

Интерфейс использует объект класса Graph1 для всех операций, обрабатывает 
пользовательский ввод через консоль и включает защиту от ошибок с 
помощью try-catch блоков. При работе с рёбрами поддерживается возможность
задания веса, а при работе с файлами пользователь может указать имя файла
для сохранения или загрузки данных.

Далее представлен программный код создания консольного интерфейса.
\inputminted{csharp}{Код/Interface.cs}

На рисунках~\ref{fig:fact-01},~\ref{fig:fact-02}  представлены примеры работы с графом через
консольный интерфейс.


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-18 220718.png}
    \caption{Консольный интерфейс}\label{fig:fact-01}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-18 220821.png}
    \caption{Информация о графе}\label{fig:fact-02}
\end{figure}


\section{Список смежности}
    \subsection{Задания}
\begin{enumerate}
    \item Для каждой вершины графа вывести её степень.
    \item Вывести все висячие вершины графа (степени 1).
    \item Построить орграф, полученный из исходного удалением изолированных вершин.
\end{enumerate}

\subsection{Реализация}

Задание 1

Класс DegreeCalculator предназначен для расчёта степеней вершин в графе, 
представленном через структуру Graph1. Он поддерживает как неориентированные, 
так и ориентированные графы.

Основные методы:
\begin{itemize}
    \item CalculateAndPrintDegrees() - Вычисляет и выводит в консоль степени (или полустепени) 
    всех вершин графа. 
    Для неориентированных графов выводит степени вершин, 
    для ориентированных - исходящую, входящую и общую степень.
    \item GetDegreeDictionary() -
Возвращает словарь, где ключами являются вершины, а значениями - их степени 
(или суммарные степени для ориентированного графа).
\end{itemize}


Класс DegreeCalculator предоставляет удобный интерфейс для анализа структуры графа 
через степени его вершин, учитывая особенности ориентированных и неориентированных графов.


Далее представлен программный код всех методов.
\inputminted{csharp}{Код/DegreeCalculator.cs}


Задание 2


Класс PendantVertices предназначен для обнаружения и анализа висячих вершин в графе 
(вершин степени 1). Он корректно обрабатывает как неориентированные, так и ориентированные графы.
Используемые методы из класса Graph1:

Основные методы
\begin{itemize}
    \item FindAndPrintPendantVertices() - Основной метод для поиска и вывода всех висячих вершин в графе.
    \item GetPendantVertices() - Возвращает упорядоченный список всех висячих вершин графа.
    \item IsPendantVertex(int vertex) Проверяет, является ли заданная вершина висячей (степени 1).
    \item GetTotalDegree(int vertex) - Вычисляет общую степень вершины.
    \item GetInDegree(int vertex) - Вычисляет количество входящих рёбер для вершины в ориентированном графе.
    \item PrintVertexInfo(int vertex) -  Выводит детальную информацию о висячей вершине.
\end{itemize}

Класс PendantVertices обеспечивает полный анализ висячих вершин, 
включая детализацию связей и статистику, 
что делает его удобным инструментом для изучения структуры графа.


Далее представлен код метода FindAndPrintPendantVertices
\inputminted{csharp}{Код/PendantVerticesFinder.cs}

Задание 3

Класс IsolatedVerticesRemover предназначен для создания нового графа, 
в котором удалены все изолированные вершины (вершины без инцидентных рёбер). 
Класс корректно обрабатывает как неориентированные, так и ориентированные графы.

Основные методы
\begin{itemize}
  \item public Graph RemoveIsolatedVertices() - Создаёт и возвращает новый граф без изолированных вершин.
  Вызывает поиск изолированных вершин и копирует остальные вершины и рёбра.
  \item public List<int> GetIsolatedVertices() - Возвращает список всех изолированных вершин в исходном графе.
Перебирает все вершины и проверяет каждую через IsIsolatedVertex.
  \item public bool IsIsolatedVertex(int vertex) -Проверяет, является ли указанная вершина изолированной.
Для неориентированных графов: степень = 0.
Для ориентированных графов: полустепени исхода и захода = 0.
\end{itemize}

Класс IsolatedVerticesRemover предоставляет безопасный и эффективный способ очистки 
графа от изолированных вершин, сохраняя при этом все остальные свойства и связи.

Далее представлен код метода IsIsolatedVertex, который позволяет проверить изолирована ли 
вершина или нет. 
\inputminted{csharp}{Код/IsolatedVerticesRemover.cs}

\subsection{Примеры}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 111310.png}
    \caption{Задание 1}\label{fig:fact-21}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 111325.png}
    \caption{Задание 2}\label{fig:fact-22}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 111345.png}
    \caption{Задание 3}\label{fig:fact-23}
\end{figure}

\section{Обходы графа}
    \subsection{Задания}
    \begin{enumerate}
        \item Корнем ацикличного орграфа называется такая вершина u, 
        что из неё существуют пути в каждую из остальных вершин орграфа. 
        Определить, имеет ли данный ацикличный орграф корень.
        \item Проверить, можно ли из графа удалить какую-либо вершину так, чтобы получилось дерево.
    \end{enumerate}

\subsection{Реализация}

Задание 1 

Вспомогательный статический класс для работы с ациклическими ориентированными графами. 
Содержит методы для поиска корневой вершины (вершины, из которой достижимы все остальные)
и проверки графа на ацикличность.

Основные методы класса
\begin{itemize}
   \item  FindRootInDAG(Graph graph) -
Основной метод поиска корня в ациклическом орграфе.
Проверяет ориентированность и отсутствие циклов, затем ищет вершины, из которых достижимы все остальные.

\item IsRoot(Graph graph, int startVertex) -
Проверяет, является ли вершина startVertex корнем, выполняя обход в глубину (DFS) и сравнивая число посещённых вершин с общим числом вершин.

\item DFS(Graph graph, int vertex, HashSet<int> visited) -
Рекурсивный обход в глубину для посещения всех достижимых вершин.

\item IsAcyclic(Graph graph) -
Проверяет граф на ацикличность с помощью DFS с отслеживанием вершин в стеке рекурсии.

\item HasCycleDFS(...) -
Вспомогательный рекурсивный метод для обнаружения циклов в графе.

\item FindRootAlternative(Graph graph) -
Альтернативный метод поиска корня через вершины с нулевой полустепенью захода.
Выводит степени захода всех вершин и проверяет кандидатов на роль корня.
\end{itemize}

Далее представлен код метода FindRootInDAG
\inputminted{csharp}{Код/RootFinder.cs}

Задание 2

Статический класс для проверки возможности преобразования графа в дерево путём удаления одной вершины. 
Поддерживает ориентированные и неориентированные графы

Основные методы

\begin{itemize}
    \item CheckVertexRemoveForTree - выводит характеристики графа и запускает соответствующую проверку.
    \item CheckForDirectedGraph - Проверяет для ориентированного графа возможность получения ориентированного дерева.
    \item IsTree - Проверяет, является ли неориентированный граф деревом (связный + без циклов).
    \item IsDirectedTree - Проверяет, является ли ориентированный граф ориентированным деревом.
    \item FindBestVertexToRemove -
Выбирает лучшую вершину для удаления (сохраняет максимум вершин).
\end{itemize}

Далее представлен код метода CheckVertexRemoveForTree
\inputminted{csharp}{Код/TreeAfterVertexRemove.cs}

\subsection{Примеры}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 130255.png}
    \caption{Задание 1}\label{fig:fact-31}
\end{figure}



\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 130626.png}
    \caption{Задание 2}\label{fig:fact-32}
\end{figure}


\section{Построение минимального остовного дерева}
    \subsection{Задания}
    \begin{enumerate}
        \item Дан взвешенный неориентированный граф из N вершин и M ребер. 
        Требуется найти в нем каркас минимального веса. Алгоритм Краскала.
    \end{enumerate}

\subsection{Реализация}

Статический класс для нахождения минимального остовного дерева (МОД) 
невзвешенного неориентированного графа с использованием алгоритма Краскала.

Основной метод 

FindMinimumSpanningTree(Graph graph)

Находит минимальное остовное дерево алгоритмом Краскала:
\begin{enumerate}
\item Проверяет, что граф неориентированный и взвешенный.

\item Собирает все рёбра, удаляет дубликаты (From < To).

\item Сортирует рёбра по весу.

\item Использует DSU для последовательного добавления рёбер, не образующих циклов.

\item Строит результирующий граф-дерево, выводит список рёбер, общий вес и список смежности.

\item Возвращает граф, представляющий минимальное остовное дерево (или лес, если граф несвязный).

Код метода FindMinimumSpanningTree

\inputminted{csharp}{Код/Kruskal.cs}

\end{enumerate}

\subsection{Примеры}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 132122.png}
    \caption{Задание}\label{fig:fact-40}
\end{figure}


\section{Взвешенный граф}
    \subsection{Задания}
    \begin{enumerate}
        \item Вывести длины кратчайших путей для всех пар вершин. Алгоритм Дейкстры.
        \item Вывести длины кратчайших путей от u до всех остальных вершин. Алгоритм Беллман-Форд
        \item Вывести кратчайшие пути до вершины u из всех остальных вершин. Алгоритм Флойда.
    \end{enumerate}

    \subsection{Реализация}
Задание 1 

Статический класс для нахождения кратчайших путей во взвешенном неориентированном графе 
с неотрицательными весами рёбер с использованием алгоритма Дейкстры.

Вложенный класс:

DijkstraResult

Содержит результаты алгоритма Дейкстры для одной исходной вершины:

\begin{itemize}
    \item SourceVertex - исходная вершина
    \item Distances - словарь кратчайших расстояний до всех вершин
    \item PreviousVertices - словарь предыдущих вершин для восстановления путей
\end{itemize}

Основные методы:
\begin{enumerate}
    \item \textbf{\texttt{FindShortestPathsFromVertex(Graph graph, int source)}}
    
    Находит кратчайшие пути от исходной вершины \texttt{source} до всех остальных:
    \begin{itemize}
        \item Проверяет наличие отрицательных весов
        \item Использует приоритетную очередь для выбора следующей вершины
        \item Возвращает объект \texttt{DijkstraResult}
    \end{itemize}
    
    \item \textbf{\texttt{FindAllPairsShortestPaths(Graph graph)}}
    
    Находит кратчайшие пути между всеми парами вершин:
    \begin{itemize}
        \item Запускает алгоритм Дейкстры из каждой вершины
        \item Выводит матрицу расстояний
        \item Анализирует связность графа
        \item Возвращает словарь результатов для всех исходных вершин
    \end{itemize}
    
    \item \textbf{\texttt{ReconstructPath(DijkstraResult result, int target)}}
    
    Восстанавливает кратчайший путь от исходной вершины (из \texttt{result}) до целевой \texttt{target}:
    \begin{itemize}
        \item Использует словарь \texttt{PreviousVertices}
        \item Возвращает список вершин в порядке следования или пустой список, если путь не существует
    \end{itemize}
\end{enumerate}






Код метода FindShortestPathsFromVertex
\inputminted{csharp}{Код/DijkstraAlgorithmNumber8.cs}


Задание 2

Класс BellmanFordAlgorithm
Статический класс для реализации алгоритма Беллмана-Форда нахождения кратчайших путей 
во взвешенном графе с возможностью обнаружения циклов отрицательного веса. 
Работает с ориентированными и неориентированными графами.

Вспомогательный класс BellmanFordResult

Хранит результаты выполнения алгоритма:
\begin{itemize}
    \item \texttt{StartVertex} - исходная вершина
    \item \texttt{Distances} - словарь кратчайших расстояний до всех вершин
    \item \texttt{Predecessors} - словарь предыдущих вершин для восстановления путей
\end{itemize}

Внутренний класс EdgeData
Представляет ребро графа с полями \texttt{From}, \texttt{To}, \texttt{Weight}.

Основные методы
\begin{enumerate}
    \item \textbf{\texttt{FindShortestPaths(Graph graph, int startVertex)}} \\
    Основной метод алгоритма Беллмана-Форда:
    \begin{itemize}
        \item Проверяет корректность входных данных
        \item Инициализирует расстояния и предшественников
        \item Выполняет релаксацию рёбер (V-1) раз
        \item Обнаруживает циклы отрицательного веса
        \item Возвращает \texttt{BellmanFordResult} или \texttt{null} при наличии цикла отрицательного веса
    \end{itemize}
    
    \item \textbf{\texttt{GetAllEdges(Graph graph)}} \\
    Вспомогательный метод: собирает список всех уникальных рёбер графа, учитывая ориентацию.
    
    \item \textbf{\texttt{CheckNegativeCycle(Graph graph, List<EdgeData> edges, Dictionary<int, double> distances)}} \\
    Проверяет наличие циклов отрицательного веса после выполнения основной части алгоритма.
    
    \item \textbf{\texttt{DisplayResults(Graph graph, int startVertex)}} \\
    Выводит результаты алгоритма в консоль в табличном формате: расстояния и пути до всех вершин.
    
    \item \textbf{\texttt{ReconstructPath(BellmanFordResult result, int targetVertex)}} \\
    Восстанавливает путь от начальной вершины до целевой в виде строки.
    
    \item \textbf{\texttt{GetPath(BellmanFordResult result, int targetVertex)}} \\
    Восстанавливает путь от начальной вершины до целевой в виде списка вершин.
\end{enumerate}

Код метода FindShortestPaths
\inputminted{csharp}{Код/BellmanFordAlgorithmNumber9.cs}

Задание 3 

Класс FloydAlgorithm

Статический класс для реализации алгоритма Флойда-Уоршелла нахождения 
кратчайших путей между всеми парами вершин во взвешенном графе 
(ориентированном или неориентированном). Обнаруживает циклы отрицательного веса.

Вложенный класс FloydResult

Содержит результаты выполнения алгоритма:
\begin{itemize}
    \item \texttt{Distances} - матрица кратчайших расстояний между всеми парами вершин
    \item \texttt{Predecessors} - матрица предшественников для восстановления путей
    \item \texttt{HasNegativeCycle} - флаг наличия цикла отрицательного веса
    \item \texttt{NegativeCycle} - список вершин, образующих цикл отрицательного веса (если есть)
\end{itemize}

Основные методы


\begin{enumerate}
    \item \textbf{\texttt{ExecuteFloydWarshall(Graph graph)}} \\
    Выполняет алгоритм Флойда-Уоршелла:
    \begin{itemize}
        \item Проверяет, что граф взвешенный
        \item Инициализирует матрицы расстояний и предшественников
        \item Основной тройной цикл для нахождения кратчайших путей через промежуточные вершины
        \item Обнаруживает циклы отрицательного веса
        \item Возвращает объект \texttt{FloydResult}
    \end{itemize}
    
    \item \textbf{\texttt{FindNegativeCycle(FloydResult result, List<int> vertices, int startIndex)}} \\
    Вспомогательный метод для обнаружения цикла отрицательного веса по результатам алгоритма.
    
    \item \textbf{\texttt{ReconstructPath(FloydResult result, List<int> vertices, int fromIndex, int toIndex)}} \\
    Восстанавливает кратчайший путь между двумя вершинами по матрице предшественников.
    
    \item \textbf{\texttt{DisplayResults(Graph graph, int startVertex)}} \\
    Основной метод вывода результатов: показывает кратчайшие пути из заданной вершины, матрицу расстояний, пути между всеми парами, предупреждение о циклах отрицательного веса.
    
    \item \textbf{\texttt{DisplayDistanceMatrix(FloydResult result, List<int> vertices)}} \\
    Выводит матрицу расстояний в читаемом формате.
    
    \item \textbf{\texttt{DisplayAllPairsPaths(FloydResult result, List<int> vertices)}} \\
    Выводит кратчайшие пути между всеми парами вершин.
    
    \item \textbf{\texttt{HasNegativeWeightCycle(Graph graph)}} \\
    Проверяет граф на наличие циклов отрицательного веса.
    
    \item \textbf{\texttt{FindShortestPath(Graph graph, int from, int to)}} \\
    Находит кратчайший путь между двумя конкретными вершинами. Возвращает кортеж (путь, расстояние).
\end{enumerate}

Код метода ExecuteFloydWarshall
\inputminted{csharp}{Код/FloidNumber10.cs}

    \subsection{Примеры}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 143141.png}
    \caption{Задание 1}\label{fig:fact-61}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 142743.png}
    \caption{Задание 2}\label{fig:fact-62}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 143518.png}
    \caption{Задание 3}\label{fig:fact-63}
\end{figure}


\section{Потоки}
    \subsection{Задание}
    Решить задачу на нахождение максимального потока любым алгоритмом. 
    Подготовить примеры, демонстрирующие работу алгоритма в разных случаях.

    \subsection{Реализация}
Класс FordFulkersonAlgorithm

Класс для реализации алгоритма Форда-Фалкерсона нахождения максимального потока в транспортной сети. 
Работает с ориентированными взвешенными графами, где веса рёбер представляют пропускные способности.

Внутренний класс FlowEdge
Представляет ребро в остаточной сети:
\begin{itemize}
    \item \texttt{To} - целевая вершина
    \item \texttt{Capacity} - остаточная пропускная способность
    \item \texttt{Reverse} - ссылка на обратное ребро
\end{itemize}

Основные методы
\begin{enumerate}
    \item \textbf{\texttt{BFS(Dictionary<int, List<FlowEdge>> residualGraph, int source, int sink, Dictionary<int, int> parent, Dictionary<int, FlowEdge> parentEdge)}} \\
    Поиск в ширину для нахождения увеличивающего пути в остаточной сети.
    
    \item \textbf{\texttt{FindMaxFlow(Graph graph, int source, int sink, out Dictionary<Tuple<int, int>, double> flow)}} \\
    Основной метод алгоритма Форда-Фалкерсона:
    \begin{itemize}
        \item Проверяет корректность входных данных
        \item Строит остаточную сеть с прямыми и обратными рёбрами
        \item Итеративно находит увеличивающие пути с помощью BFS
        \item Обновляет потоки и остаточные пропускные способности
        \item Возвращает значение максимального потока и распределение потоков по рёбрам
    \end{itemize}
    
    \item \textbf{\texttt{Demonstrate(Graph graph)}} \\
    Демонстрационный метод: автоматически выбирает исходную и стоковую вершины, вычисляет и выводит максимальный поток.
    
    \item \textbf{\texttt{GetSourceVertex(Graph graph)}} \\
    Вспомогательный метод: находит вершину с минимальной входящей степенью (кандидат на источник).
    
    \item \textbf{\texttt{GetSinkVertex(Graph graph, int source)}} \\
    Вспомогательный метод: находит вершину с минимальной исходящей степенью, отличную от источника (кандидат на сток).
    
    \item \textbf{\texttt{CalculateInDegree(Graph graph, int vertex)}} \\
    Вспомогательный метод: вычисляет входящую степень вершины в ориентированном графе.
    
    \item \textbf{\texttt{FindMaxFlowInteractive(Graph graph)}} \\
    Интерактивный метод: позволяет пользователю выбрать исходную и стоковую вершины, затем вычисляет и выводит максимальный поток с детализацией по рёбрам.
\end{enumerate}
Код метода FindMaxFlow
\inputminted{csharp}{Код/FordAfikerson.cs}

    \subsection{Примеры}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{Скрины/Снимок экрана 2025-12-19 145740.png}
    \caption{Задание 3}\label{fig:fact-70}
\end{figure}



    
\end{document}
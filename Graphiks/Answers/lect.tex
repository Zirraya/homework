\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage[english, russian] {babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{minted}
\usepackage{float}
\usepackage{amssymb}

\title{КГ упрощенная версия}
\author{silvia.lesnaia }


\begin{document}

\maketitle


\section{Интерактивное приложение. Интерактивная машинная графика}

Интерактивное приложение — приложение с которым пользователь имеет возможность динамически взаимодействовать.
Интерактивная графика — графика с которой пользователь имеет возможность
динамически взаимодействовать, манипулировать содержимым изображения, его
формой, размером и цветом на поверхности дисплея с помощью интерактивных
устройств управления. Такими устройствами могут быть любые устройства ввода:
клавиатура, мышь или события операционной системы.


\section{Событийно-ориентированное программирование. Основные варианты событий и их обработчиков при построении интерактивного графического приложения.}

Событийно-ориентированное программирование — это парадигма программирования,
 в которой выполнение программы определяется событиями — действиями пользователя (клавиатура, мышь), 
 сообщениями других программ и потоков, событиями
операционной системы (например, поступлением сетевого пакета). 
Событию можно назначить обработчик события, то есть функцию, которая сработает, как только
событие произошло. Парадигма наличия обработчиков события не обязательно связана с ООП.


\section{ Декартова система координат (ДСК). Модельная (локальная, объектная) система координат. Система координат экрана.}


\textbf{Декартова система координат} 

система двух или трёх перпендикулярных
друг другу осей, пересекающихся в одной точке — начале отсчёта (начале координат) 
с общей единицей длины. Также ДСК называется прямоугольной СК.

\textbf{Модельная (локальная, объектная) система координат} 

координатная
система, которая является локальной для объекта, т.е. начинается в той же точке,
что и сам объект. Все вершины модели находятся в локальном пространстве: все
их координаты являются локальными по отношению к объекту. Далее модельная
система координат может совершать со своим объектом все движения в мировой
системе координат.

\textbf{Система координат экрана} 

система координат экрана монитора. В отличие
от перечисленных выше систем координат, 
экранная обычно имеет дискретные целочисленные координаты. Может быть левой (начало находится слева сверху) или
правой (начало находится слева снизу).

\section{Вывод преобразования кадрирования без сохранения пропорций изображения.}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 204809.png}
\end{figure}

\section{ Сохранение пропорций изображения при преобразовании кадрирования.}

Чтобы сохранить пропорции изображения при операции кадрирования,
 нужно домножать обе размерности на один и тот же коэффициент.

Чтобы не выходить за кадр нужно:

1. Соотношение сторон рисунка и окна рисования $\frac{V_x}{W_x} $. Больший коэффицент покажет, по 
какой размерности выйдет наше изображение за рамки кадра/экрана. Нужно вычислить коэффицент по которой 
изображение не выйдет за рамки кадра/экрана.

2. $\frac{V_x}{W_x} > \frac{V_y}{W_y} \Rightarrow  \frac{W_x}{V_x}$

$\frac{V_x}{W_x} < \frac{V_y}{W_y} \Rightarrow  \frac{W_y}{V_y}$


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 205542.png}
\end{figure}


\section{Однородные координаты. Переход от евклидовых к однородным координатам и обратно.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 205647.png}
\end{figure}

Пример:
Из евклидовых в однородные

$ P(2,3,2) \Rightarrow (2*2,2*3,2*2,2) $


Из однородных в евклидовые 

$(4,6,4,2) \Rightarrow (4/2,6/2,4/2) = (2,3,2)$




\section{ 2D-преобразования — масштабирование и поворот относительно начала координат. Получение матриц преобразований. Обратные преобразования.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210032.png}
\end{figure}

Обратный: $\frac{1}{S_x} \frac{1}{S_y} \frac{1}{S_z}$

$-\theta$


\section{2D-преобразование — перенос. Получение матрицы преобразования. Обратное преобразование.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210133.png}
\end{figure}

Обратный: -Tx,Ty

\section{ Совмещение 2D-преобразований. Получение матрицы совмещенного преобразования. Обратное преобразование для совмещенного преобразования.}


Когда последовательность элементарных преобразований применяется к изображению, 
возможны два подхода к выполнению такой задачи: либо рассматривается
последовательность изображений, где каждое последующее изображение получено с
помощью очередного элементарного преобразования над предыдущим, 
либо получение результата из исходного изображения происходит в результате применения
единого сложного преобразования — комбинации элементарных преобразований.
Такое сложное преобразование будем назвать «совмещенное преобразование»


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210227.png}
\end{figure}

\section{Алгоритм Коэна-Сазерленда отсечения невидимых линий.}

 Этот алгоритм позволяет быстро выявить отрезки, которые
могут быть или приняты, или отброшены целиком. 
Вычисление пересечений требуется, когда отрезок не попадает ни в один из этих классов.

Идея алгоритма состоит в следующем: прямые линии, ограничивающие область
видимости, делят всё двумерное пространство на 9 областей. Каждой из областей
присваивается 4-х-разрядный двоичный код:

 единица в 1-ом разряде — область слева от левой границы области видимости;

 единица во 2-ом разряде — область справа от правой границы области видимости;

 единица в 3-ем разряде — область под нижней границей области видимости;

 единица в 4-ом разряде — область над верхней границей области видимости.



\begin{figure} [H]
    \includegraphics[width=0.70\linewidth]{Снимок экрана 2025-11-19 210323.png}
\end{figure}


\section{ Алгоритм построения простого графика функции: двумерного, трехмерного}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210410.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210437.png}
\end{figure}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210445.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210451.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210825.png}
\end{figure}



\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 210840.png}
\end{figure}


\section{Мировая система координат. Модельное преобразование. Вывод матрицы варианта модельного преобразования.}

\textbf{Мировая система координат}

Система координат всего изображения, в которой привязываются его составные
элементы. азис МСК с такой ориентацией осей является правосторонним. Как мы уже оговаривали ранее, расстоянию в
один пиксел по горизонтали в системе координат экрана соответствует расстояние в
мировой системе координат равное $V_x/W _x$ . Координаты в мировом пространстве — это
как раз то, о чем говорит их название: координаты всех ваших вершин относительно
(игрового) мира. Это координатное пространство, в котором вы бы хотели видеть
ваши объекты преобразованными таким образом, что бы они были распределены
в пространстве (и желательно реалистично). Координаты вашего объекта преобразуются из локального в мировое пространство — модельное преобразование; это
выполняется посредством матрицы модели (матрицы модельного преобразования).


\textbf{Модельное преобразование}

матрица, которая перемещает, масштабирует и/или вращает ваш объект для его расположения в мировом пространстве в позиции/ориентации
в которой объект должен находиться. Стоит учитывать, что модельная матрица для
рисунка должна представлять собой преобразование в котором сначала производится начальная установка рисунка в начало координат, а потом проводится привязка,
описанная командами translate, scale и rotate, то есть она получается в результате
произведения матриц M и initM.




\section{3D-преобразования — масштабирование и вращение относительно осей координат. Получение матриц преобразований. Обратные преобразования}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 211116.png}
\end{figure}

Обратный: $\frac{1}{S_x} \frac{1}{S_y} \frac{1}{S_z}$


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 211124.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 211129.png}
\end{figure}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 211133.png}
\end{figure}



\section{3D-преобразование — перенос. Получение матрицы преобразования. Обратное преобразование.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 211302.png}
\end{figure}

Обратный: -Tx,-Ty,-Tz


\section{Скалярное произведение. Геометрический смысл скалярного произведения.Векторное произведение. Вывод матрицы векторного произведения.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215205.png}
\end{figure}
\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215256.png}
\end{figure}

\section{Двойственность преобразований (каждого из преобразований). Переход от одного базиса ДСК к другому}


Любое из приведенных выше преобразований можно рассматривать 
как преобразование изображения (например перенос точки из одной части изображения в
другую). Но в то же время преобразование, 
примененное ко всем точкам изображения можно рассматривать как преобразование системы координат.
 Так, например,
перенос точек в положительном направлении оси Ox можно рассматривать как сдвиг
системы координат в отрицательном направлении оси Ox, а поворот точек против
часовой стрелки относительно начала координат можно рассматривать как поворот
системы координат по часовой стрелке.


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215256.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215432.png}
\end{figure}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215506.png}
\end{figure}



\section{Трехмерное вращение относительно оси, проходящей через начало координат. Вывод формулы Родригеса.}


Вход: ось — единичный вектор $\overline{n}$; угол $\theta$; точка P и соответствующий ей радиусвектор p.
Выход: вектор $\overline{p}$
 $\overline{p}'$ — радиус-вектор точки P'
, являющейся поворотом точки P вокруг
оси $\overline{n}$ на $\theta$ градусов против часовой стрелки


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Без имени.png}
\end{figure}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 215950.png}
\end{figure}

\section{ Матрица преобразования нормалей.}

В компьютерной графике невозможно обойтись без эффектов освещения. А для
построения более-менее реалистичной модели освещения нужны нормали объекта.
Но мы обычно проводим различные манипуляции с объектами в виде матриц

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 220156.png}
\end{figure}

$\overline{n}$ - нормаль после применения преобзравонаие

$\overline{n}$  нормаль к одной из граней треугольника

M - матрица viev

\section{Система координат наблюдателя (СКН). Переход от мировой системы координат к СКН. Вывод матрицы преобразования LookAt.}

Система координат наблюдателя - правая декартова система координат, начало которой
лежит в точке наблюдения, а ось О противоположно направлена вектору наблюдения. Таким
образом, для перехода от мировой системы координат к системе координат наблюдателя
необходимо:
1. перенести начало координат в точку наблюдения;

2. организовать вращение осей координат таким образом, чтобы ось Oz была направлена
в сторону, противоположную вектору наблюдения, а ось Оу была направлена вверх
(лежала в одной плоскости с осью Oz и вектором $\overline{u}$).

Первое преобразование простое: достаточно к однородным координатам каждой точки
применить преобразование переноса с коэффициентами $T_x = -x_s, Ty = -y_s, T_z = - z_s,$ т.е.
необходимо выполнить преобразование заданное матрицей

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 220610.png}
\end{figure}

\section{Организация интерактивного движения в пространстве наблюдателя}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 220653.png}
\end{figure}

В итоге, для осуществления шага вперёд на единицу нам достаточно осуществить преобразование:
LookAt((0, 0, -1),(0, 0, -2),(0, 1, 0)).


Повороты наблюдателя (относительно оси Oy): $LookAt((0, 0, 0), R(-\theta, e2) · P, e2).$


Наклоны наблюдателя: $LookAt((0, 0, 0), R(-\theta, e1) · P, e2).$


Обходы наблюдателем (вращение вокруг удалённой точки): $LookAt(S',(0, 0, -dist), e2).$


\section{Система координат пространства отсечения. Вывод матрицы преобразования Ortho.}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 220936.png}
\end{figure}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 220959.png}
\end{figure}

\section{Система координат пространства отсечения. Вывод матрицы преобразования Frustum}


 Если проведём всевозможные лучи, исходящие из глаза наблюдателя, проходящие через окно
наблюдения, то они образуют бесконечную 4-х-угольную пирамиду с вершиной в
глазу наблюдателя. Ограничим видимую часть сцены окном наблюдения с одной
стороны (z = -near) и плоскостью z = -f ar. Считается, что дальше плоскости
z = -f ar наблюдатель ничего не видит. Получается усечённая 4-х-угольная пирамида 
(frustum), боковые грани её опираются на окно наблюдения.

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 221153.png}
\end{figure}

\section{Система координат пространства отсечения. Вывод матрицы преобразования Perspective.}


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 221252.png}
\end{figure}

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 221318.png}
\end{figure}

\section{Растеризация отрезка. Алгоритм Брезенхема.}

Алгоритм Брезенхема растеризации отрезка — это алгоритм, определяющий, какие
точки двумерного растра нужно закрасить, чтобы получить близкое приближение
прямой линии между двумя заданными точками


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 221619.png}
\end{figure}


\section{Растеризация многоугольника. Алгоритм построчного заполнения}

Алгоритм основан на том, что соседние пикселы в строке одинаковы и меняются
только там, где строка пересекается с ребром многоугольника, для этого достаточно
определить x-координаты пересечений строк сканирования с рёбрами.


Перед началом алгоритма стоит выполнить следующие действия:
1. Подготовить служебные целочисленные массивы y-координат вершин и номеров вершин.

2. Совместно отсортировать y-координаты по возрастанию и массив номеров
вершин для того, чтобы можно было определить исходный номер вершины.

3. Определить пределы заполнения по оси Oy — ymin и ymax. Ввести переменные
ycur и ycr, последняя служит для поддержания критической точки — следующей ближайшей строки y, 
на которой встречается вершина.

\section{Алгоритм, использующий Z-буфер.}

Z-буфер — это специальная память (двумерный массив), которая хранит для каждого пикселя экрана не цвет,
 а его глубину (координату Z). 
 Глубина показывает, насколько далеко этот пиксель от камеры.

 Для решения поставленной задачи создадим двумерный массив, у которого строк
и столбцов столько же, сколько и точек растра у экрана. Для начала все элементы
такого массива инициализируются максимальным значением координаты z, которое
может быть у точки сцены — это 1, а всем точкам растрового пространства придаются атрибуты фона

Теперь поочерёдно выбираем объекты сцены и проводим их растеризацию. Выбираем объект, и, зная координаты z его вершин, проводим растеризацию многоугольника, в результате чего мы получаем соответствие каждому пикселю, на которые
проецируется данный объект, некое значение координаты z в диапазоне от -1 до
1. Если значение для пикселя меньше значения в Z-буфере, то мы помещаем это
значение в наш двумерный массив, а пиксел перекрашиваем в цвет объекта, который
мы проецировали.

\section{Элементы OpenGL: Графический конвейер}

Для отрисовки объектов на трёхмерной сцене объекты должны пройти множество
преобразований. Изначально положение модели задаётся в её собственной локальной
СК. Последовательно применяем следующие преобразования:

1. modelView — модельное преобразование, переход в мировую СК.

2. cameraView — переход в СК наблюдателя.

3. clipView — переход в пространство отсечения.

4. С — переход к размерности целевого изображения.

После этого мы проводим растеризацию объектов, проводим тест глубины с
использованием алгорима Z-буфера, и нам остаётся только изобразить полученные
точки на экране.

Все эти операции необходимо выполнить для пикселя. Это приведёт к замедлению работы приложения, при использовании мощностей центрального процессора.
Для решения этой проблемы можно использовать графический процессор (видеокарту). Специальные программы для видеокарты называются шейдерами.
Шейдеры пишутся на языке GLSL (OpenGL Shading Language), синтаксис которого схож с синтаксисом языка C. На изображении ниже можно увидеть примерное
представление всех этапов графического конвейера. Синим выделены этапы, для
которых можно специфицировать собственные шейдеры.

Графический конвейер содержит большое количество секций, где каждая занимается своей частью обработки вершинных данных в полностью отрисованный пиксел.

На вход конвейера передается массив 3D координат — вершинные данные, набор
вершин (вершина — vertex). Каждая вершина задается своими трехмерными координатами и, возможно, дополнительными атрибутами (например, цвет). Во время
отрисовки системе следует указать, что составить из переданного набора данных:
набор точек, набор треугольников или просто одну ломаную линию (такие фигуры
называются примитивами)


Первый этап конвейера — вершинный шейдер (Vertex Shader), который принимает на вход одну вершину. Основная задача вершинного шейдера — преобразование
одних 3D-координат в другие. Возможность изменения этого шейдера позволяет
выполнять преобразования в зависимости от параметров вершин. Предполагается,
что на выходе вершинного шейдера координаты вершины заданы в пространстве
отсечения.

Второй этап — сборка примитивов. Это этап, который принимает на вход все
вершины от вершинного шейдера, формирующие примитив, и собирает из них сам
примитив.

Результат этапа сборки примитивов передается геометрическому шейдеру (Geometry
Shader). Он в свою очередь на вход принимает набор вершин, формирующих примитивы, из которого может сформировать новый набор возможно иных примитивов.
Результат работы геометрического шейдера передается на этап растеризации, где
результирующие примитивы будут соотноситься с пикселами на экране, формируя
«фрагмент» для фрагментного шейдера (Fragment Shader). Фрагмент в OpenGL —
все данные, которые нужны OpenGL для того, чтобы отрисовать пиксел. 
Перед выполнением фрагментного шейдера выполняется отсечение примитива
 (по умолчанию, относительно куба от -1 до 1 по каждой из осей), при котором отбрасываются
все его части, которые находятся вне поля зрения, повышая таким образом производительность.


Основная цель фрагментного шейдера — вычисление конечного цвета пиксела.
Зачастую фрагментный шейдер содержит всю информацию о 3D сцене, которую
можно использовать для модификации финального цвета (типа освещения, теней,
цвета источника света и т.д.).

После того, как определение всех соответствующих цветовых значений будет
закончено, результат пройдет еще один этап, который называется альфа тестирование и смешивание. Этот этап проверяет соответствующее значение глубины (мы
вернемся к этому позже) фрагмента и использует его для проверки местоположения фрагмента относительно других объектов: спереди или сзади. Этот этап также
проверяет значения прозрачности и смешивает цвета, если это необходимо. Таким
образом, результирующий цвет пиксела может отличаться от цвета, вычисленного
фрагментным шейдером. Обычно геометрический шейдер оставляется стандартным.
Но на видеокартах не существует стандартного вершинного и фрагментного шейдера, в следствие чего в современном OpenGL их приходится задавать самостоятельно.


\section{Вершинные данные. Вершинный массив. Вершинный буфер}

Данные о вершиннах -  массив 3D координат

Вершинные данные — это набор вершин

Вершина — это набор данных поверх
3D координаты, которыми могут выступать любые атрибуты, например, цвет.


Вершинный массив - органицаия вершыннх данных.

Вершинный буфер - управление памятью GPU, которая хранит большое количество в памяти вершин.


После определения вершинных данных требуется передать их в первый этап
графического конвейера: в вершинный шейдер. Для того, чтобы вершинный шейдер
обработал требуемое количество вершин, необходимо выделить память на GPU,
в которой будут сохранены вершинные данные, указать OpenGL то, как он должен
интерпретировать переданные ему данные, и сообщить GPU количество этих данных.

Эта память управляется через объекты вершинного буфера (vertex buffer objects
(VBO)), которые могут хранить большое количество вершин в памяти GPU. 
Преимущество использования таких объектов буфера заключается в возможности посылать
в видеокарту большое количество наборов данных за один раз, а не по одной вершине.

В OpenGL есть большое количество различных типов буферных объектов, так
что каждый буферный объект должен быть привязан к контексту, через который и
происходит общение с ним. Например, чтобы переслать данные из массива vertices в
буферный объект vertexBuffer нужно сначала привязать буферный объект к контексту.

Для VBO характерен контекст $GL_ARRAY_BUFFER$, то есть буферный объект
рассматривается как массив вершинных данных. После этой привязки все операции
с $GL_ARRAY_BUFFER$ будут относиться к vertexBuffer.

Вершинные данные организуются с помощью объектов вершинного массива
(Vertex Array Object). Создается такой объект с помощью glGenVertexArrays. Для
накопления информации в вершинном массиве его следует сделать активным. Теперь последующие команды, относящиеся к наполнению/изменению/чтению памяти
GPU, будут ассоциироваться с этим объектом.


\section{Шейдерная программа (варианты шейдеров). Порядок работы. Uniformпеременные}

Шейдер — программа, исполняемая на графическом процессоре (GPU). Компиляция шейдера производится не во время сборки всего приложения, а в ходе выполнения приложения — для той архитектуры GPU, которая является актуальной при
запуске.

Шейдеры загружаются в систему в составе шейдерной программы. Шейдерная
программа — комбинация шейдеров, используемая для некоторого набора данных.
В эту комбинацию обязательно входят один вершинный шейдер и один фрагментный шейдер. Возможно присутствие по одному экземпляру шейдера каждого другого
вида. Для того чтобы составить шейдерную программу, нужно определить текст каждого шейдера, скомпилировать его, провести сборку скомпилированных шейдеров в
единое целое.

При соединении шейдеров в программу переменные, объявленные выходными в
одном шейдере (если такое объявление имело место), сопоставляются с входными
переменными другого шейдера. Если входные и выходные значения не совпадают,
сборка программы закончится неудачей, и может быть получен протокол о соответствующих ошибках.
Скомпилированные шейдеры должны присоединяться к программе в том порядке, 
в котором они должны работать: сначала вершинный шейдер, а затем фрагментный.

Uniform-переменные — глобальные переменных шейдеров. Uniform-переменные
определяются для шейдерной программы и к ним возможен доступ из любого шейдера.
 Значение uniform-переменной загружается в GPU с помощью семейства процедур
glUniform
\section{Типы источников света: точечный, линейный, плоскостной, бесконечно удаленный. Влияние типа источника света на освещенность точки.}

Точечный источник представляет из себя точку, которая имеет заданное положение в пространстве, 
равномерно излучающую свет во всех направлениях. 
Интенсивность света обратно пропорциональна квадрату расстояния от источника до
объекта сцены.

\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 225501.png}
\end{figure}


Линейный источник представляет из себя бесконечную прямую в заданном
положении в пространстве сцены, которая равномерно излучает свет относительно
этой линии. Интенсивность освещения вычисляется интегрированием по прямой.


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 225506.png}
\end{figure}


Плоскостной источник света имеет заданное положение 
в пространстве и равномерно излучает свет относительно плоскости, 
а интенсивность освещения не зависит
от расстояния.







\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 225511.png}
\end{figure}


Бесконечно удаленный источник света — это тот же плоскостной источник за
несколькими отличиями:

1. Он всегда освещает только одну и ту же строну объекта, т. к. объект не может
его достигнуть и пролететь сквозь него.

2. У бесконечно удалённого источника света нельзя измерить расстояние до объекта.

\section{Модель освещения Фонга.}

В реальности фоновая освещённость складывается из очень большого количества
источников света, подавляющую часть которых составляют отражённые, 
и воссоздание такой модели либо очень трудно, либо невозможно, т.к. это требует большого
количества вычислений. Поэтому используют упрощённый способ: 
каждому источнику света задают вектор ambient — интенсивность фонового освещения 
этого источника для всех объектов сцены. 

toy - цвет поверхности. 

$I_result = Attenuation * I_{toy} * I_{ambient}$


Диффузная освещенность объекта в произвольной точке зависит от угла падения
вектора от источника света в точку на поверхности объекта.

Вектор нормали - n 

Вектор  напрваления на источник света из точки l

$I_result = Attenuation * (I_{toy} * I_{diffuse})max(0, \overline{n} * \overline{l})$

Бликовая освещенность

Вектор r — вектор отраженного света. 

Вектор v —
задает вектор направления из точки плоскости в точку наблюдателя. 

Параметр глянцевости - shinness.


$I_result = Attenuation * (I_{toy} * I_{specullar})(max(0, \overline{r} * \overline{v}))^{shinness}$


\section{ Модель освещения Блинна-Фонга.}

Данная модель незначительно отличается от предыдущей и её появление обусловлено следующим: 
из-за выбора угла $]theta$ (аргумента косинуса) подобным образом границы
блика могут быть явными, что негативно сказывается на реалистичности изображения. 
Поэтому в данной модели угол выбирается иным способом. Вводится медианный вектор h, направление которого является средним между направлениями
вектора падения и вектора, направленного в глаз наблюдателю, h необходимо нормировать. 
Далее выбирается угол $\psi $ между этим вектором и вектором нормали к
поверхности и уже этот угол будет аргументом косинуса.


$I_result = Attenuation * (I_{toy} * I_{specullar})(max(0, \overline{h} * \overline{n}))^{shinness}$

\section{Модели затенения Гуро и Фонга}


Иногда для обеспечения реалистичности изображения требуется скруглять углы и
линии пересечения граней объекта.
 Для решения этой проблемы призван алгоритм затенения, заключающийся в следующем: 
 вектор нормали к вершине
вычисляется как средний вектор между всеми нормалями граней, которые сходятся
в вершине, и нормируется.
Зная такой вектор, мы можем вычислить цвет каждой вершины многогранника и
приписать его каждой вершине соответствующей грани.
 Далее в процессе растеризации цвет усреднится по ребрам и граням многогранника. 
 Так получим сглаженный
многогранник. Такая модель закраски называется моделью Гуро.



Модель Фонга строится похожим способом, только в процессе растеризации
усредняется не цвет, а нормали, то есть, несмотря на то, что грань плоская,
 в каждой точке грани будет свой вектор нормали. В этом случае плоская грань может
восприниматься как выпуклая.


\begin{figure} [H]
    \includegraphics[width=1\linewidth]{Снимок экрана 2025-11-19 230942.png}
\end{figure}

\section{Порядок реализации модели Гуро с помощью шейдеров в OpenGL.}

На картинке ниже видно, что вычислением цвета занимается вершинный шейдер,
фрагментный шейдер же просто «пропускает» сквозь себя вычисленный ранее результат. 
На этапе растеризации (между работой вершинного и фрагментного шейдеров) 
интерполируется уже вычисленный ранее цвет, плавно переходя от одной
вершины к другой. По этой причине блики отображаться не будут. (координаты в
переменной glP ostition — это координаты вершины в СК пространства отсечения)

\section{Порядок реализации модели Фонга с помощью шейдеров в OpenGL.}

В этой модели вершинный шейдер на выходе даёт нормаль и координаты вершины
в СК наблюдателя. В процессе растеризации интерполируются обе эти составляющие, и только во фрагментном шейдере происходит вычисление цвета для каждого
фрагмента каждой грани, при этом известно положение наблюдателя — начальная
точка СК. Получается, что в данной модели происходит значительно больше вычислений, чем в модели Гуро, но результат является более реалистичным, в том числе
происходит корректная обработка бликов.







\end{document}
.model small
.stack 100h             ; Сегмент стека
.186                     ; Разрешение трансляции команд процессора 80186
.data                     ; Сегмент данных

array db 20 dup(0)      ; Массив simple, содержащий 20 чисел
result db '      ', '$' ; Строка символов result для вывода чисел на экран (ширина 6 символов)
nl db 13, 10, '$'       ; Строка nl для перевода курсора вниз и возврата к левому краю экрана

.code                    ; Сегмент кода
start:                   ; Точка входа в программу

    mov ax, @data       ; Инициализация сегментного регистра DS
    mov ds, ax          ; Установка сегмента данных

    ; Заполняем первую половину массива кратными 5
    mov cx, 10          ; Число шагов в цикле (10)
    mov bx, 0           ; Индекс для массива
    mov al, 5           ; Начальное значение кратного 5
fill_multiples:
        mov array[bx], al ; Сохраняем число кратное 5 в массив
        add al, 5        ; Увеличиваем значение кратного 5
        inc bx            ; Переход к следующему элементу массива
        loop fill_multiples

    ; Заполняем вторую половину массива квадратами кратных 5
    mov cx, 10          ; Число шагов в цикле (10)
    mov bx, 10         ; Индекс для массива (начинаем с 10-го элемента)
    mov al, 5           ; Начальное значение кратного 5
fill_squares:
        mov ah, al       ; AH = AL (для умножения)
        mul ah           ; AL = AL * AL (квадрат)
        mov array[bx], al ; Сохраняем квадрат числа в массив
        add al, 5        ; Увеличиваем значение кратного 5
        inc bx            ; Переход к следующему элементу массива
        loop fill_squares

    ; Вывод массива на экран в виде таблицы 2x10
    mov cx, 20          ; Число шагов в цикле (20 элементов)
    mov bx, 0           ; Индекс для массива
    mov dx, 0           ; Счетчик строк (0 - первая строка)
print_array:
        mov al, array[bx] ; Загружаем элемент массива
        call byte_asc     ; Преобразование числа в строку
        lea dx, nl        ; Перевод курсора вниз после каждой строки
        int 21h            ; Вызов DOS для вывода новой строки
        inc bx            ; Переход к следующему элементу массива
        inc dx            ; Увеличиваем счетчик строк
        cmp dx, 1          ; Проверяем, достигли ли конца первой строки
        jl print_array     ; Если нет, продолжаем вывод
        mov dx, 0           ; Обнуляем счетчик строк для второй строки
        jmp print_array    ; Продолжаем вывод с начала второй строки

    mov ax, 4C00h       ; Завершение программы
    int 21h

byte_asc proc            ; Процедура преобразования числа в строку
    pusha                ; Сохраняем все регистры общего назначения
    mov cx, 6            ; Максимальная длина строки (6 символов)
    lea di, result + 5   ; Указываем на начало строки (справа налево)
    mov ax, [di - 5]     ; Загружаем число из массива
    mov bl, 10          ; Основание системы счисления (десятичная)
    mov ah, 0           ; Обнуляем AH
    xor cx, cx          ; Счетчик цифр
convert_loop:        
    div bl               ; Делим AX на 10 (результат в AL, остаток в AH)
    add ah, '0'          ; Преобразуем остаток в символ
    dec di              ; Двигаемся влево по строке
    mov [di], ah         ; Сохраняем символ в строке
    inc cx               ; Увеличиваем счетчик цифр
    test ax, ax          ; Проверяем, не ноль ли AX
    jnz convert_loop      ; Если не ноль, продолжаем преобразование

    lea dx, result       ; Загружаем адрес строки для вывода
    mov ah, 09h          ; Функция вывода строки
    int 21h              ; Вызов DOS для вывода строки

    popa                 ; Восстанавливаем регистры общего назначения
    ret                  ; Возврат в точку вызова
byte_asc endp           ; Конец процедуры

end start                ; Конец программы